module.exports = {

"[project]/node_modules/better-auth/dist/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "BetterAuthError": (()=>B),
    "HIDE_METADATA": (()=>se),
    "MissingDependencyError": (()=>tt),
    "betterAuth": (()=>au),
    "capitalizeFirstLetter": (()=>Yi),
    "createCookieGetter": (()=>Ne),
    "createLogger": (()=>Ue),
    "deleteSessionCookie": (()=>M),
    "generateId": (()=>H),
    "generateState": (()=>ve),
    "getCookies": (()=>it),
    "levels": (()=>je),
    "logger": (()=>C),
    "parseCookies": (()=>vo),
    "parseSetCookieHeader": (()=>ho),
    "parseState": (()=>At),
    "setCookieCache": (()=>Be),
    "setSessionCookie": (()=>D),
    "shouldPublishLog": (()=>mn)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/better-call/dist/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$base64$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@better-auth/utils/dist/base64.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hmac$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@better-auth/utils/dist/hmac.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hash$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@better-auth/utils/dist/hash.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hex$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@better-auth/utils/dist/hex.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$random$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@better-auth/utils/dist/random.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$binary$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@better-auth/utils/dist/binary.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$defu$2f$dist$2f$defu$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/defu/dist/defu.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$scrypt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@noble/hashes/esm/scrypt.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uncrypto$2f$dist$2f$crypto$2e$node$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uncrypto/dist/crypto.node.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/zod/lib/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$util$2f$decode_protected_header$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/jose/dist/node/esm/util/decode_protected_header.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwt$2f$verify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/jose/dist/node/esm/jwt/verify.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$util$2f$decode_jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/jose/dist/node/esm/util/decode_jwt.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$key$2f$import$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/jose/dist/node/esm/key/import.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwt$2f$sign$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/jose/dist/node/esm/jwt/sign.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$dialect$2f$sqlite$2f$sqlite$2d$dialect$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/kysely/dist/esm/dialect/sqlite/sqlite-dialect.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$dialect$2f$mysql$2f$mysql$2d$dialect$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/kysely/dist/esm/dialect/mysql/mysql-dialect.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$dialect$2f$postgres$2f$postgres$2d$dialect$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/kysely/dist/esm/dialect/postgres/postgres-dialect.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$dialect$2f$mssql$2f$mssql$2d$dialect$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/kysely/dist/esm/dialect/mssql/mssql-dialect.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$kysely$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/kysely/dist/esm/kysely.js [app-route] (ecmascript)");
;
;
;
var Ye = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createMiddleware"])(async ()=>({})), ce = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createMiddlewareCreator"])({
    use: [
        Ye,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createMiddleware"])(async ()=>({}))
    ]
}), E = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createEndpointCreator"])({
    use: [
        Ye
    ]
});
function De(e) {
    return e === "-" || e === "^" || e === "$" || e === "+" || e === "." || e === "(" || e === ")" || e === "|" || e === "[" || e === "]" || e === "{" || e === "}" || e === "*" || e === "?" || e === "\\" ? `\\${e}` : e;
}
function Sr(e) {
    let t = "";
    for(let r = 0; r < e.length; r++)t += De(e[r]);
    return t;
}
function Xe(e, t = !0) {
    if (Array.isArray(e)) return `(?:${e.map((c)=>`^${Xe(c, t)}$`).join("|")})`;
    let r = "", n = "", o = ".";
    t === !0 ? (r = "/", n = "[/\\\\]", o = "[^/\\\\]") : t && (r = t, n = Sr(r), n.length > 1 ? (n = `(?:${n})`, o = `((?!${n}).)`) : o = `[^${n}]`);
    let i = t ? `${n}+?` : "", d = t ? `${n}*?` : "", l = t ? e.split(r) : [
        e
    ], s = "";
    for(let a = 0; a < l.length; a++){
        let c = l[a], p = l[a + 1], m = "";
        if (!(!c && a > 0)) {
            if (t && (a === l.length - 1 ? m = d : p !== "**" ? m = i : m = ""), t && c === "**") {
                m && (s += a === 0 ? "" : m, s += `(?:${o}*?${m})*?`);
                continue;
            }
            for(let u = 0; u < c.length; u++){
                let f = c[u];
                f === "\\" ? u < c.length - 1 && (s += De(c[u + 1]), u++) : f === "?" ? s += o : f === "*" ? s += `${o}*?` : s += De(f);
            }
            s += m;
        }
    }
    return s;
}
function _r(e, t) {
    if (typeof t != "string") throw new TypeError(`Sample must be a string, but ${typeof t} given`);
    return e.test(t);
}
function Ae(e, t) {
    if (typeof e != "string" && !Array.isArray(e)) throw new TypeError(`The first argument must be a single pattern string or an array of patterns, but ${typeof e} given`);
    if ((typeof t == "string" || typeof t == "boolean") && (t = {
        separator: t
    }), arguments.length === 2 && !(typeof t > "u" || typeof t == "object" && t !== null && !Array.isArray(t))) throw new TypeError(`The second argument must be an options object or a string/boolean separator, but ${typeof t} given`);
    if (t = t || {}, t.separator === "\\") throw new Error("\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead");
    let r = Xe(e, t.separator), n = new RegExp(`^${r}$`, t.flags), o = _r.bind(null, n);
    return o.options = t, o.pattern = e, o.regexp = n, o;
}
var Re = Object.create(null), le = (e)=>globalThis.process?.env || globalThis.Deno?.env.toObject() || globalThis.__env__ || (e ? Re : globalThis), N = new Proxy(Re, {
    get (e, t) {
        return le()[t] ?? Re[t];
    },
    has (e, t) {
        let r = le();
        return t in r || t in Re;
    },
    set (e, t, r) {
        let n = le(!0);
        return n[t] = r, !0;
    },
    deleteProperty (e, t) {
        if (!t) return !1;
        let r = le(!0);
        return delete r[t], !0;
    },
    ownKeys () {
        let e = le(!0);
        return Object.keys(e);
    }
});
function Ir(e) {
    return e ? e !== "false" : !1;
}
var ke = typeof process < "u" && process.env && ("TURBOPACK compile-time value", "development") || "", ue = ke === "production", Te = ke === "dev" || ke === "development", et = ke === "test" || Ir(N.TEST);
var B = class extends Error {
    constructor(t, r){
        super(t), this.name = "BetterAuthError", this.message = t, this.cause = r, this.stack = "";
    }
}, tt = class extends B {
    constructor(t){
        super(`The package "${t}" is required. Make sure it is installed.`, t);
    }
};
function Pr(e) {
    try {
        return new URL(e).pathname !== "/";
    } catch  {
        throw new B(`Invalid base URL: ${e}. Please provide a valid base URL.`);
    }
}
function Ce(e, t = "/api/auth") {
    return Pr(e) ? e : (t = t.startsWith("/") ? t : `/${t}`, `${e}${t}`);
}
function pe(e, t) {
    if (e) return Ce(e, t);
    let r = N.BETTER_AUTH_URL || N.NEXT_PUBLIC_BETTER_AUTH_URL || N.PUBLIC_BETTER_AUTH_URL || N.NUXT_PUBLIC_BETTER_AUTH_URL || N.NUXT_PUBLIC_AUTH_URL || (N.BASE_URL !== "/" ? N.BASE_URL : void 0);
    if (r) return Ce(r, t);
    if ("undefined" < "u" && window.location) return Ce(window.location.origin, t);
}
function rt(e) {
    try {
        return new URL(e).origin;
    } catch  {
        return null;
    }
}
function nt(e) {
    return e.includes("://") ? new URL(e).host : e;
}
var ot = ce(async (e)=>{
    if (e.request?.method !== "POST") return;
    let { body: t, query: r, context: n } = e, o = e.headers?.get("origin") || e.headers?.get("referer") || "", i = t?.callbackURL || r?.callbackURL, d = t?.redirectTo, l = r?.currentURL, s = t?.errorCallbackURL, a = t?.newUserCallbackURL, c = n.trustedOrigins, p = e.headers?.has("cookie"), m = (f, g)=>f.startsWith("/") ? !1 : g.includes("*") ? Ae(g)(nt(f)) : f.startsWith(g), u = (f, g)=>{
        if (!f) return;
        if (!c.some((A)=>m(f, A) || f?.startsWith("/") && g !== "origin" && !f.includes(":"))) throw e.context.logger.error(`Invalid ${g}: ${f}`), e.context.logger.info(`If it's a valid URL, please add ${f} to trustedOrigins in your auth config
`, `Current list of trustedOrigins: ${c}`), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("FORBIDDEN", {
            message: `Invalid ${g}`
        });
    };
    p && !e.context.options.advanced?.disableCSRFCheck && u(o, "origin"), i && u(i, "callbackURL"), d && u(d, "redirectURL"), l && u(l, "currentURL"), s && u(s, "errorCallbackURL"), a && u(d, "newUserCallbackURL");
});
;
;
var V = (e, t = "ms")=>new Date(Date.now() + (t === "sec" ? e * 1e3 : e));
;
var ee = (e, t)=>{
    let r = ()=>{
        switch(t){
            case "ms":
                return e;
            case "s":
                return e * 1e3;
            case "m":
                return e * 1e3 * 60;
            case "h":
                return e * 1e3 * 60 * 60;
            case "d":
                return e * 1e3 * 60 * 60 * 24;
            case "w":
                return e * 1e3 * 60 * 60 * 24 * 7;
            case "y":
                return e * 1e3 * 60 * 60 * 24 * 365;
        }
    }, n = {
        t: `${e}${t}`,
        value: e,
        tFormat: t,
        toMilliseconds: r,
        toSeconds: ()=>n.toMilliseconds() / 1e3,
        toMinutes: ()=>n.toSeconds() / 60,
        toHours: ()=>n.toMinutes() / 60,
        toDays: ()=>n.toHours() / 24,
        toWeeks: ()=>n.toDays() / 7,
        toYears: ()=>n.toDays() / 365,
        getDate: ()=>new Date(Date.now() + n.toMilliseconds()),
        add: (o)=>{
            let i = typeof o == "string" ? fe(o).toMilliseconds() : o.toMilliseconds();
            return ee(n.toMilliseconds() + i, "ms");
        },
        subtract: (o)=>{
            let i = typeof o == "string" ? fe(o).toMilliseconds() : o.toMilliseconds();
            return ee(n.toMilliseconds() - i, "ms");
        },
        multiply: (o)=>ee(n.toMilliseconds() * o, "ms"),
        divide: (o)=>ee(n.toMilliseconds() / o, "ms"),
        equals: (o)=>{
            let i = typeof o == "string" ? fe(o).toMilliseconds() : o.toMilliseconds();
            return n.toMilliseconds() === i;
        },
        lessThan: (o)=>{
            let i = typeof o == "string" ? fe(o).toMilliseconds() : o.toMilliseconds();
            return n.toMilliseconds() < i;
        },
        greaterThan: (o)=>{
            let i = typeof o == "string" ? fe(o).toMilliseconds() : o.toMilliseconds();
            return n.toMilliseconds() > i;
        },
        format: (o)=>{
            let i = n.getDate();
            return o.replace(/YYYY|MM|DD|HH|mm|ss/g, (d)=>{
                switch(d){
                    case "YYYY":
                        return i.getFullYear().toString();
                    case "MM":
                        return (i.getMonth() + 1).toString().padStart(2, "0");
                    case "DD":
                        return i.getDate().toString().padStart(2, "0");
                    case "HH":
                        return i.getHours().toString().padStart(2, "0");
                    case "mm":
                        return i.getMinutes().toString().padStart(2, "0");
                    case "ss":
                        return i.getSeconds().toString().padStart(2, "0");
                    default:
                        return d;
                }
            });
        },
        fromNow: ()=>{
            let o = n.toMilliseconds();
            return o < 0 ? n.ago() : o < 1e3 ? "in a few seconds" : o < 6e4 ? `in ${Math.round(o / 1e3)} seconds` : o < 36e5 ? `in ${Math.round(o / 6e4)} minutes` : o < 864e5 ? `in ${Math.round(o / 36e5)} hours` : o < 6048e5 ? `in ${Math.round(o / 864e5)} days` : o < 26298e5 ? `in ${Math.round(o / 6048e5)} weeks` : o < 315576e5 ? `in ${Math.round(o / 26298e5)} months` : `in ${Math.round(o / 315576e5)} years`;
        },
        ago: ()=>{
            let o = -n.toMilliseconds();
            return o < 0 ? n.fromNow() : o < 1e3 ? "a few seconds ago" : o < 6e4 ? `${Math.round(o / 1e3)} seconds ago` : o < 36e5 ? `${Math.round(o / 6e4)} minutes ago` : o < 864e5 ? `${Math.round(o / 36e5)} hours ago` : o < 6048e5 ? `${Math.round(o / 864e5)} days ago` : o < 26298e5 ? `${Math.round(o / 6048e5)} weeks ago` : o < 315576e5 ? `${Math.round(o / 26298e5)} months ago` : `${Math.round(o / 315576e5)} years ago`;
        }
    };
    return n;
}, fe = (e)=>{
    let t = e.match(/^(\d+)(ms|s|m|h|d|w|y)$/);
    if (!t) throw new Error("Invalid time format");
    return ee(parseInt(t[1]), t[2]);
};
;
function ho(e) {
    let t = new Map;
    return e.split(", ").forEach((n)=>{
        let o = n.split(";").map((p)=>p.trim()), [i, ...d] = o, [l, ...s] = i.split("="), a = s.join("=");
        if (!l || a === void 0) return;
        let c = {
            value: a
        };
        d.forEach((p)=>{
            let [m, ...u] = p.split("="), f = u.join("="), g = m.trim().toLowerCase();
            switch(g){
                case "max-age":
                    c["max-age"] = f ? parseInt(f.trim(), 10) : void 0;
                    break;
                case "expires":
                    c.expires = f ? new Date(f.trim()) : void 0;
                    break;
                case "domain":
                    c.domain = f ? f.trim() : void 0;
                    break;
                case "path":
                    c.path = f ? f.trim() : void 0;
                    break;
                case "secure":
                    c.secure = !0;
                    break;
                case "httponly":
                    c.httponly = !0;
                    break;
                case "samesite":
                    c.samesite = f ? f.trim().toLowerCase() : void 0;
                    break;
                default:
                    c[g] = f ? f.trim() : !0;
                    break;
            }
        }), t.set(l, c);
    }), t;
}
function Ne(e) {
    let r = (e.advanced?.useSecureCookies !== void 0 ? e.advanced?.useSecureCookies : e.baseURL !== void 0 ? !!e.baseURL.startsWith("https://") : ue) ? "__Secure-" : "", n = !!e.advanced?.crossSubDomainCookies?.enabled, o = n ? e.advanced?.crossSubDomainCookies?.domain || (e.baseURL ? new URL(e.baseURL).hostname : void 0) : void 0;
    if (n && !o) throw new B("baseURL is required when crossSubdomainCookies are enabled");
    function i(d, l = {}) {
        let s = e.advanced?.cookiePrefix || "better-auth", a = e.advanced?.cookies?.[d]?.name || `${s}.${d}`, c = e.advanced?.cookies?.[d]?.attributes;
        return {
            name: `${r}${a}`,
            attributes: {
                secure: !!r,
                sameSite: "lax",
                path: "/",
                httpOnly: !0,
                ...n ? {
                    domain: o
                } : {},
                ...e.advanced?.defaultCookieAttributes,
                ...l,
                ...c
            }
        };
    }
    return i;
}
function it(e) {
    let t = Ne(e), r = e.session?.expiresIn || ee(7, "d").toSeconds(), n = t("session_token", {
        maxAge: r
    }), o = t("session_data", {
        maxAge: e.session?.cookieCache?.maxAge || 60 * 5
    }), i = t("dont_remember");
    return {
        sessionToken: {
            name: n.name,
            options: n.attributes
        },
        sessionData: {
            name: o.name,
            options: o.attributes
        },
        dontRememberToken: {
            name: i.name,
            options: i.attributes
        }
    };
}
async function Be(e, t) {
    if (e.context.options.session?.cookieCache?.enabled) {
        let n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$base64$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["base64Url"].encode(JSON.stringify({
            session: t,
            expiresAt: V(e.context.authCookies.sessionData.options.maxAge || 60, "sec").getTime(),
            signature: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hmac$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createHMAC"])("SHA-256", "base64urlnopad").sign(e.context.secret, JSON.stringify(t))
        }), {
            padding: !1
        });
        if (n.length > 4093) throw new B("Session data is too large to store in the cookie. Please disable session cookie caching or reduce the size of the session data");
        e.setCookie(e.context.authCookies.sessionData.name, n, e.context.authCookies.sessionData.options);
    }
}
async function D(e, t, r, n) {
    let o = e.context.authCookies.sessionToken.options, i = r ? void 0 : e.context.sessionConfig.expiresIn;
    await e.setSignedCookie(e.context.authCookies.sessionToken.name, t.session.token, e.context.secret, {
        ...o,
        maxAge: i,
        ...n
    }), r && await e.setSignedCookie(e.context.authCookies.dontRememberToken.name, "true", e.context.secret, e.context.authCookies.dontRememberToken.options), await Be(e, t), e.context.setNewSession(t), e.context.options.secondaryStorage && await e.context.secondaryStorage?.set(t.session.token, JSON.stringify({
        user: t.user,
        session: t.session
    }), Math.floor((new Date(t.session.expiresAt).getTime() - Date.now()) / 1e3));
}
function M(e) {
    e.setCookie(e.context.authCookies.sessionToken.name, "", {
        ...e.context.authCookies.sessionToken.options,
        maxAge: 0
    }), e.setCookie(e.context.authCookies.sessionData.name, "", {
        ...e.context.authCookies.sessionData.options,
        maxAge: 0
    }), e.setCookie(e.context.authCookies.dontRememberToken.name, "", {
        ...e.context.authCookies.dontRememberToken.options,
        maxAge: 0
    });
}
function vo(e) {
    let t = e.split("; "), r = new Map;
    return t.forEach((n)=>{
        let [o, i] = n.split("=");
        r.set(o, i);
    }), r;
}
var Nr = Object.defineProperty, Br = Object.defineProperties, jr = Object.getOwnPropertyDescriptors, st = Object.getOwnPropertySymbols, Fr = Object.prototype.hasOwnProperty, qr = Object.prototype.propertyIsEnumerable, at = (e, t, r)=>t in e ? Nr(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r, te = (e, t)=>{
    for(var r in t || (t = {}))Fr.call(t, r) && at(e, r, t[r]);
    if (st) for (var r of st(t))qr.call(t, r) && at(e, r, t[r]);
    return e;
}, re = (e, t)=>Br(e, jr(t)), Vr = class extends Error {
    constructor(e, t, r){
        super(t || e.toString(), {
            cause: r
        }), this.status = e, this.statusText = t, this.error = r;
    }
}, $r = async (e, t)=>{
    var r, n, o, i, d, l;
    let s = t || {}, a = {
        onRequest: [
            t?.onRequest
        ],
        onResponse: [
            t?.onResponse
        ],
        onSuccess: [
            t?.onSuccess
        ],
        onError: [
            t?.onError
        ],
        onRetry: [
            t?.onRetry
        ]
    };
    if (!t || !t?.plugins) return {
        url: e,
        options: s,
        hooks: a
    };
    for (let c of t?.plugins || []){
        if (c.init) {
            let p = await ((r = c.init) == null ? void 0 : r.call(c, e.toString(), t));
            s = p.options || s, e = p.url;
        }
        a.onRequest.push((n = c.hooks) == null ? void 0 : n.onRequest), a.onResponse.push((o = c.hooks) == null ? void 0 : o.onResponse), a.onSuccess.push((i = c.hooks) == null ? void 0 : i.onSuccess), a.onError.push((d = c.hooks) == null ? void 0 : d.onError), a.onRetry.push((l = c.hooks) == null ? void 0 : l.onRetry);
    }
    return {
        url: e,
        options: s,
        hooks: a
    };
}, dt = class {
    constructor(e){
        this.options = e;
    }
    shouldAttemptRetry(e, t) {
        return this.options.shouldRetry ? Promise.resolve(e < this.options.attempts && this.options.shouldRetry(t)) : Promise.resolve(e < this.options.attempts);
    }
    getDelay() {
        return this.options.delay;
    }
}, Mr = class {
    constructor(e){
        this.options = e;
    }
    shouldAttemptRetry(e, t) {
        return this.options.shouldRetry ? Promise.resolve(e < this.options.attempts && this.options.shouldRetry(t)) : Promise.resolve(e < this.options.attempts);
    }
    getDelay(e) {
        return Math.min(this.options.maxDelay, this.options.baseDelay * 2 ** e);
    }
};
function zr(e) {
    if (typeof e == "number") return new dt({
        type: "linear",
        attempts: e,
        delay: 1e3
    });
    switch(e.type){
        case "linear":
            return new dt(e);
        case "exponential":
            return new Mr(e);
        default:
            throw new Error("Invalid retry strategy");
    }
}
var Hr = (e)=>{
    let t = {}, r = (n)=>typeof n == "function" ? n() : n;
    if (e?.auth) {
        if (e.auth.type === "Bearer") {
            let n = r(e.auth.token);
            if (!n) return t;
            t.authorization = `Bearer ${n}`;
        } else if (e.auth.type === "Basic") {
            let n = r(e.auth.username), o = r(e.auth.password);
            if (!n || !o) return t;
            t.authorization = `Basic ${btoa(`${n}:${o}`)}`;
        } else if (e.auth.type === "Custom") {
            let n = r(e.auth.value);
            if (!n) return t;
            t.authorization = `${r(e.auth.prefix)} ${n}`;
        }
    }
    return t;
}, ut = [
    "get",
    "post",
    "put",
    "patch",
    "delete"
];
var Wr = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function Gr(e) {
    let t = e.headers.get("content-type"), r = new Set([
        "image/svg",
        "application/xml",
        "application/xhtml",
        "application/html"
    ]);
    if (!t) return "json";
    let n = t.split(";").shift() || "";
    return Wr.test(n) ? "json" : r.has(n) || n.startsWith("text/") ? "text" : "blob";
}
function Kr(e) {
    try {
        return JSON.parse(e), !0;
    } catch  {
        return !1;
    }
}
function pt(e) {
    if (e === void 0) return !1;
    let t = typeof e;
    return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.buffer ? !1 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function";
}
function ct(e) {
    try {
        return JSON.parse(e);
    } catch  {
        return e;
    }
}
function lt(e) {
    return typeof e == "function";
}
function Qr(e) {
    if (e?.customFetchImpl) return e.customFetchImpl;
    if (typeof globalThis < "u" && lt(globalThis.fetch)) return globalThis.fetch;
    if ("undefined" < "u" && lt(window.fetch)) return window.fetch;
    throw new Error("No fetch implementation found");
}
function Jr(e) {
    let t = new Headers(e?.headers), r = Hr(e);
    for (let [n, o] of Object.entries(r || {}))t.set(n, o);
    if (!t.has("content-type")) {
        let n = Zr(e?.body);
        n && t.set("content-type", n);
    }
    return t;
}
function Zr(e) {
    return pt(e) ? "application/json" : null;
}
function Yr(e) {
    if (!e?.body) return null;
    let t = new Headers(e?.headers);
    return pt(e.body) && !t.has("content-type") ? JSON.stringify(e.body) : e.body;
}
function Xr(e, t) {
    var r;
    if (t?.method) return t.method.toUpperCase();
    if (e.startsWith("@")) {
        let n = (r = e.split("@")[1]) == null ? void 0 : r.split("/")[0];
        return ut.includes(n) ? n.toUpperCase() : t?.body ? "POST" : "GET";
    }
    return t?.body ? "POST" : "GET";
}
function en(e, t) {
    let r;
    return !e?.signal && e?.timeout && (r = setTimeout(()=>t?.abort(), e?.timeout)), {
        abortTimeout: r,
        clearTimeout: ()=>{
            r && clearTimeout(r);
        }
    };
}
function tn(e, t) {
    let { baseURL: r, params: n, query: o } = t || {
        query: {},
        params: {},
        baseURL: ""
    }, i = e.startsWith("http") ? e.split("/").slice(0, 3).join("/") : r;
    if (!i) throw new TypeError(`Invalid URL ${e}. Are you passing in a relative URL but not setting the baseURL?`);
    if (e.startsWith("@")) {
        let p = e.toString().split("@")[1].split("/")[0];
        ut.includes(p) && (e = e.replace(`@${p}/`, "/"));
    }
    i.endsWith("/") || (i += "/");
    let [d, l] = e.replace(i, "").split("?"), s = new URLSearchParams(l);
    for (let [p, m] of Object.entries(o || {}))s.set(p, String(m));
    if (n) if (Array.isArray(n)) {
        let p = d.split("/").filter((m)=>m.startsWith(":"));
        for (let [m, u] of p.entries()){
            let f = n[m];
            d = d.replace(u, f);
        }
    } else for (let [p, m] of Object.entries(n))d = d.replace(`:${p}`, String(m));
    d = d.split("/").map(encodeURIComponent).join("/"), d.startsWith("/") && (d = d.slice(1));
    let a = s.size > 0 ? `?${s}`.replace(/\+/g, "%20") : "";
    return new URL(`${d}${a}`, i);
}
var v = async (e, t)=>{
    var r, n, o, i, d, l, s, a;
    let { hooks: c, url: p, options: m } = await $r(e, t), u = Qr(m), f = new AbortController, g = (r = m.signal) != null ? r : f.signal, b = tn(p, m), A = Yr(m), R = Jr(m), h = Xr(p, m), y = re(te({}, m), {
        url: b,
        headers: R,
        body: A,
        method: h,
        signal: g
    });
    for (let F of c.onRequest)if (F) {
        let P = await F(y);
        P instanceof Object && (y = P);
    }
    ("pipeTo" in y && typeof y.pipeTo == "function" || typeof ((n = t?.body) == null ? void 0 : n.pipe) == "function") && ("duplex" in y || (y.duplex = "half"));
    let { clearTimeout: x } = en(m, f), k = await u(y.url, y);
    x();
    let be = {
        response: k,
        request: y
    };
    for (let F of c.onResponse)if (F) {
        let P = await F(re(te({}, be), {
            response: (o = t?.hookOptions) != null && o.cloneResponse ? k.clone() : k
        }));
        P instanceof Response ? k = P : P instanceof Object && (k = P.response);
    }
    if (k.ok) {
        if (!(y.method !== "HEAD")) return {
            data: "",
            error: null
        };
        let P = Gr(k), G = {
            data: "",
            response: k,
            request: y
        };
        if (P === "json" || P === "text") {
            let K = await k.text(), Ur = await ((i = y.jsonParser) != null ? i : ct)(K);
            G.data = Ur;
        } else G.data = await k[P]();
        y?.output && y.output && !y.disableValidation && (G.data = y.output.parse(G.data));
        for (let K of c.onSuccess)K && await K(re(te({}, G), {
            response: (d = t?.hookOptions) != null && d.cloneResponse ? k.clone() : k
        }));
        return t?.throw ? G.data : {
            data: G.data,
            error: null
        };
    }
    let Er = (l = t?.jsonParser) != null ? l : ct, Je = await k.text(), Le = Kr(Je) ? await Er(Je) : {}, vr = {
        response: k,
        request: y,
        error: re(te({}, Le), {
            status: k.status,
            statusText: k.statusText
        })
    };
    for (let F of c.onError)F && await F(re(te({}, vr), {
        response: (s = t?.hookOptions) != null && s.cloneResponse ? k.clone() : k
    }));
    if (t?.retry) {
        let F = zr(t.retry), P = (a = t.retryAttempt) != null ? a : 0;
        if (await F.shouldAttemptRetry(P, k)) {
            for (let K of c.onRetry)K && await K(be);
            let G = F.getDelay(P);
            return await new Promise((K)=>setTimeout(K, G)), await v(e, re(te({}, t), {
                retryAttempt: P + 1
            }));
        }
    }
    if (t?.throw) throw new Vr(k.status, k.statusText, Le);
    return {
        data: null,
        error: re(te({}, Le), {
            status: k.status,
            statusText: k.statusText
        })
    };
};
;
;
;
;
async function ft(e) {
    let t = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hash$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createHash"])("SHA-256").digest(e);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$base64$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["base64Url"].encode(new Uint8Array(t), {
        padding: !1
    });
}
function Ee(e) {
    return {
        tokenType: e.token_type,
        accessToken: e.access_token,
        refreshToken: e.refresh_token,
        accessTokenExpiresAt: e.expires_in ? V(e.expires_in, "sec") : void 0,
        scopes: e?.scope ? typeof e.scope == "string" ? e.scope.split(" ") : e.scope : [],
        idToken: e.id_token
    };
}
async function O({ id: e, options: t, authorizationEndpoint: r, state: n, codeVerifier: o, scopes: i, claims: d, redirectURI: l, duration: s }) {
    let a = new URL(r);
    if (a.searchParams.set("response_type", "code"), a.searchParams.set("client_id", t.clientId), a.searchParams.set("state", n), a.searchParams.set("scope", i.join(" ")), a.searchParams.set("redirect_uri", t.redirectURI || l), o) {
        let c = await ft(o);
        a.searchParams.set("code_challenge_method", "S256"), a.searchParams.set("code_challenge", c);
    }
    if (d) {
        let c = d.reduce((p, m)=>(p[m] = null, p), {});
        a.searchParams.set("claims", JSON.stringify({
            id_token: {
                email: null,
                email_verified: null,
                ...c
            }
        }));
    }
    return s && a.searchParams.set("duration", s), a;
}
;
async function U({ code: e, codeVerifier: t, redirectURI: r, options: n, tokenEndpoint: o, authentication: i }) {
    let d = new URLSearchParams, l = {
        "content-type": "application/x-www-form-urlencoded",
        accept: "application/json",
        "user-agent": "better-auth"
    };
    if (d.set("grant_type", "authorization_code"), d.set("code", e), t && d.set("code_verifier", t), d.set("redirect_uri", r), i === "basic") {
        let p = btoa(`${n.clientId}:${n.clientSecret}`);
        l.authorization = `Basic ${p}`;
    } else d.set("client_id", n.clientId), d.set("client_secret", n.clientSecret);
    let { data: s, error: a } = await v(o, {
        method: "POST",
        body: d,
        headers: l
    });
    if (a) throw a;
    return Ee(s);
}
;
;
;
;
;
;
function mt(e, t) {
    let r = new Uint8Array(e), n = new Uint8Array(t);
    if (r.length !== n.length) return !1;
    let o = 0;
    for(let i = 0; i < r.length; i++)o |= r[i] ^ n[i];
    return o === 0;
}
;
;
;
var ie = {
    N: 16384,
    r: 16,
    p: 1,
    dkLen: 64
};
async function ht(e, t) {
    return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$scrypt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["scryptAsync"])(e.normalize("NFKC"), t, {
        N: ie.N,
        p: ie.p,
        r: ie.r,
        dkLen: ie.dkLen,
        maxmem: 128 * ie.N * ie.r * 2
    });
}
var yt = async (e)=>{
    let t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hex$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hex"].encode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uncrypto$2f$dist$2f$crypto$2e$node$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRandomValues"])(new Uint8Array(16))), r = await ht(e, t);
    return `${t}:${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hex$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["hex"].encode(r)}`;
}, wt = async ({ hash: e, password: t })=>{
    let [r, n] = e.split(":"), o = await ht(t, r);
    return mt(o, new Uint8Array(Buffer.from(n, "hex")));
};
;
var me = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$random$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createRandomStringGenerator"])("a-z", "0-9", "A-Z", "-_");
async function ve(e, t) {
    let r = e.body?.callbackURL || (e.query?.currentURL ? rt(e.query?.currentURL) : "") || e.context.options.baseURL;
    if (!r) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "callbackURL is required"
    });
    let n = me(128), o = me(32), i = JSON.stringify({
        callbackURL: r,
        codeVerifier: n,
        errorURL: e.body?.errorCallbackURL || e.query?.currentURL,
        newUserURL: e.body?.newUserCallbackURL,
        link: t,
        expiresAt: Date.now() + 10 * 60 * 1e3
    }), d = new Date;
    d.setMinutes(d.getMinutes() + 10);
    let l = await e.context.internalAdapter.createVerificationValue({
        value: i,
        identifier: o,
        expiresAt: d
    });
    if (!l) throw e.context.logger.error("Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("INTERNAL_SERVER_ERROR", {
        message: "Unable to create verification"
    });
    return {
        state: l.identifier,
        codeVerifier: n
    };
}
async function At(e) {
    let t = e.query.state || e.body.state, r = await e.context.internalAdapter.findVerificationValue(t);
    if (!r) throw e.context.logger.error("State Mismatch. Verification not found", {
        state: t
    }), e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`);
    let n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        callbackURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
        codeVerifier: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
        errorURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional(),
        newUserURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional(),
        expiresAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].number(),
        link: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
            email: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
            userId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string()
        }).optional()
    }).parse(JSON.parse(r.value));
    if (n.errorURL || (n.errorURL = `${e.context.baseURL}/error`), n.expiresAt < Date.now()) throw await e.context.internalAdapter.deleteVerificationValue(r.id), e.context.logger.error("State expired.", {
        state: t
    }), e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`);
    return await e.context.internalAdapter.deleteVerificationValue(r.id), n;
}
var Rt = (e)=>{
    let t = "https://appleid.apple.com/auth/token";
    return {
        id: "apple",
        name: "Apple",
        createAuthorizationURL ({ state: r, scopes: n, redirectURI: o }) {
            let i = n || [
                "email",
                "name"
            ];
            return e.scope && i.push(...e.scope), new URL(`https://appleid.apple.com/auth/authorize?client_id=${e.clientId}&response_type=code&redirect_uri=${e.redirectURI || o}&scope=${i.join(" ")}&state=${r}&response_mode=form_post`);
        },
        validateAuthorizationCode: async ({ code: r, codeVerifier: n, redirectURI: o })=>U({
                code: r,
                codeVerifier: n,
                redirectURI: e.redirectURI || o,
                options: e,
                tokenEndpoint: t
            }),
        async verifyIdToken (r, n) {
            if (e.disableIdTokenSignIn) return !1;
            if (e.verifyIdToken) return e.verifyIdToken(r, n);
            let o = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$util$2f$decode_protected_header$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeProtectedHeader"])(r), { kid: i, alg: d } = o;
            if (!i || !d) return !1;
            let l = await fn(i), { payload: s } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwt$2f$verify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jwtVerify"])(r, l, {
                algorithms: [
                    d
                ],
                issuer: "https://appleid.apple.com",
                audience: e.appBundleIdentifier || e.clientId,
                maxTokenAge: "1h"
            });
            return [
                "email_verified",
                "is_private_email"
            ].forEach((a)=>{
                s[a] !== void 0 && (s[a] = !!s[a]);
            }), n && s.nonce !== n ? !1 : !!s;
        },
        async getUserInfo (r) {
            if (e.getUserInfo) return e.getUserInfo(r);
            if (!r.idToken) return null;
            let n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$util$2f$decode_jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeJwt"])(r.idToken);
            if (!n) return null;
            let o = n.user ? `${n.user.name.firstName} ${n.user.name.lastName}` : n.email, i = await e.mapProfileToUser?.(n);
            return {
                user: {
                    id: n.sub,
                    name: o,
                    emailVerified: !1,
                    email: n.email,
                    ...i
                },
                data: n
            };
        }
    };
}, fn = async (e)=>{
    let t = "https://appleid.apple.com", r = "/auth/keys", { data: n } = await v(`${t}${r}`);
    if (!n?.keys) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "Keys not found"
    });
    let o = n.keys.find((i)=>i.kid === e);
    if (!o) throw new Error(`JWK with kid ${e} not found`);
    return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$key$2f$import$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["importJWK"])(o, o.alg);
};
var kt = (e)=>({
        id: "discord",
        name: "Discord",
        createAuthorizationURL ({ state: t, scopes: r, redirectURI: n }) {
            let o = r || [
                "identify",
                "email"
            ];
            return e.scope && o.push(...e.scope), new URL(`https://discord.com/api/oauth2/authorize?scope=${o.join("+")}&response_type=code&client_id=${e.clientId}&redirect_uri=${encodeURIComponent(e.redirectURI || n)}&state=${t}&prompt=${e.prompt || "none"}`);
        },
        validateAuthorizationCode: async ({ code: t, redirectURI: r })=>U({
                code: t,
                redirectURI: e.redirectURI || r,
                options: e,
                tokenEndpoint: "https://discord.com/api/oauth2/token"
            }),
        async getUserInfo (t) {
            if (e.getUserInfo) return e.getUserInfo(t);
            let { data: r, error: n } = await v("https://discord.com/api/users/@me", {
                headers: {
                    authorization: `Bearer ${t.accessToken}`
                }
            });
            if (n) return null;
            if (r.avatar === null) {
                let i = r.discriminator === "0" ? Number(BigInt(r.id) >> BigInt(22)) % 6 : parseInt(r.discriminator) % 5;
                r.image_url = `https://cdn.discordapp.com/embed/avatars/${i}.png`;
            } else {
                let i = r.avatar.startsWith("a_") ? "gif" : "png";
                r.image_url = `https://cdn.discordapp.com/avatars/${r.id}/${r.avatar}.${i}`;
            }
            let o = await e.mapProfileToUser?.(r);
            return {
                user: {
                    id: r.id,
                    name: r.display_name || r.username || "",
                    email: r.email,
                    emailVerified: r.verified,
                    image: r.image_url,
                    ...o
                },
                data: r
            };
        }
    });
var Tt = (e)=>({
        id: "facebook",
        name: "Facebook",
        async createAuthorizationURL ({ state: t, scopes: r, redirectURI: n }) {
            let o = r || [
                "email",
                "public_profile"
            ];
            return e.scope && o.push(...e.scope), await O({
                id: "facebook",
                options: e,
                authorizationEndpoint: "https://www.facebook.com/v21.0/dialog/oauth",
                scopes: o,
                state: t,
                redirectURI: n
            });
        },
        validateAuthorizationCode: async ({ code: t, redirectURI: r })=>U({
                code: t,
                redirectURI: e.redirectURI || r,
                options: e,
                tokenEndpoint: "https://graph.facebook.com/oauth/access_token"
            }),
        async getUserInfo (t) {
            if (e.getUserInfo) return e.getUserInfo(t);
            let { data: r, error: n } = await v("https://graph.facebook.com/me?fields=id,name,email,picture", {
                auth: {
                    type: "Bearer",
                    token: t.accessToken
                }
            });
            if (n) return null;
            let o = await e.mapProfileToUser?.(r);
            return {
                user: {
                    id: r.id,
                    name: r.name,
                    email: r.email,
                    image: r.picture.data.url,
                    emailVerified: r.email_verified,
                    ...o
                },
                data: r
            };
        }
    });
var Et = (e)=>{
    let t = "https://github.com/login/oauth/access_token";
    return {
        id: "github",
        name: "GitHub",
        createAuthorizationURL ({ state: r, scopes: n, codeVerifier: o, redirectURI: i }) {
            let d = n || [
                "user:email"
            ];
            return e.scope && d.push(...e.scope), O({
                id: "github",
                options: e,
                authorizationEndpoint: "https://github.com/login/oauth/authorize",
                scopes: d,
                state: r,
                redirectURI: i
            });
        },
        validateAuthorizationCode: async ({ code: r, redirectURI: n })=>U({
                code: r,
                redirectURI: e.redirectURI || n,
                options: e,
                tokenEndpoint: t
            }),
        async getUserInfo (r) {
            if (e.getUserInfo) return e.getUserInfo(r);
            let { data: n, error: o } = await v("https://api.github.com/user", {
                headers: {
                    "User-Agent": "better-auth",
                    authorization: `Bearer ${r.accessToken}`
                }
            });
            if (o) return null;
            let i = !1, { data: d } = await v("https://api.github.com/user/emails", {
                headers: {
                    authorization: `Bearer ${r.accessToken}`,
                    "User-Agent": "better-auth"
                }
            });
            d && (n.email = (d.find((s)=>s.primary) ?? d[0])?.email, i = d.find((s)=>s.email === n.email)?.verified ?? !1);
            let l = await e.mapProfileToUser?.(n);
            return {
                user: {
                    id: n.id.toString(),
                    name: n.name || n.login,
                    email: n.email,
                    image: n.avatar_url,
                    emailVerified: i,
                    ...l
                },
                data: n
            };
        }
    };
};
var je = [
    "info",
    "success",
    "warn",
    "error",
    "debug"
];
function mn(e, t) {
    return je.indexOf(t) <= je.indexOf(e);
}
var z = {
    reset: "\x1B[0m",
    bright: "\x1B[1m",
    dim: "\x1B[2m",
    underscore: "\x1B[4m",
    blink: "\x1B[5m",
    reverse: "\x1B[7m",
    hidden: "\x1B[8m",
    fg: {
        black: "\x1B[30m",
        red: "\x1B[31m",
        green: "\x1B[32m",
        yellow: "\x1B[33m",
        blue: "\x1B[34m",
        magenta: "\x1B[35m",
        cyan: "\x1B[36m",
        white: "\x1B[37m"
    },
    bg: {
        black: "\x1B[40m",
        red: "\x1B[41m",
        green: "\x1B[42m",
        yellow: "\x1B[43m",
        blue: "\x1B[44m",
        magenta: "\x1B[45m",
        cyan: "\x1B[46m",
        white: "\x1B[47m"
    }
}, gn = {
    info: z.fg.blue,
    success: z.fg.green,
    warn: z.fg.yellow,
    error: z.fg.red,
    debug: z.fg.magenta
}, hn = (e, t)=>{
    let r = new Date().toISOString();
    return `${z.dim}${r}${z.reset} ${gn[e]}${e.toUpperCase()}${z.reset} ${z.bright}[Better Auth]:${z.reset} ${t}`;
}, Ue = (e)=>{
    let t = e?.disabled !== !0, r = e?.level ?? "error", n = (o, i, d = [])=>{
        if (!t || !mn(r, o)) return;
        let l = hn(o, i);
        if (!e || typeof e.log != "function") {
            o === "error" ? console.error(l, ...d) : o === "warn" ? console.warn(l, ...d) : console.log(l, ...d);
            return;
        }
        e.log(o === "success" ? "info" : o, l, ...d);
    };
    return Object.fromEntries(je.map((o)=>[
            o,
            (...[i, ...d])=>n(o, i, d)
        ]));
}, C = Ue();
;
var vt = (e)=>({
        id: "google",
        name: "Google",
        async createAuthorizationURL ({ state: t, scopes: r, codeVerifier: n, redirectURI: o }) {
            if (!e.clientId || !e.clientSecret) throw C.error("Client Id and Client Secret is required for Google. Make sure to provide them in the options."), new B("CLIENT_ID_AND_SECRET_REQUIRED");
            if (!n) throw new B("codeVerifier is required for Google");
            let i = r || [
                "email",
                "profile",
                "openid"
            ];
            e.scope && i.push(...e.scope);
            let d = await O({
                id: "google",
                options: e,
                authorizationEndpoint: "https://accounts.google.com/o/oauth2/auth",
                scopes: i,
                state: t,
                codeVerifier: n,
                redirectURI: o
            });
            return e.accessType && d.searchParams.set("access_type", e.accessType), e.prompt && d.searchParams.set("prompt", e.prompt), d;
        },
        validateAuthorizationCode: async ({ code: t, codeVerifier: r, redirectURI: n })=>U({
                code: t,
                codeVerifier: r,
                redirectURI: e.redirectURI || n,
                options: e,
                tokenEndpoint: "https://oauth2.googleapis.com/token"
            }),
        async verifyIdToken (t, r) {
            if (e.disableIdTokenSignIn) return !1;
            if (e.verifyIdToken) return e.verifyIdToken(t, r);
            let n = `https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=${t}`, { data: o } = await v(n);
            return o ? o.aud === e.clientId && o.iss === "https://accounts.google.com" : !1;
        },
        async getUserInfo (t) {
            if (e.getUserInfo) return e.getUserInfo(t);
            if (!t.idToken) return null;
            let r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$util$2f$decode_jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeJwt"])(t.idToken), n = await e.mapProfileToUser?.(r);
            return {
                user: {
                    id: r.sub,
                    name: r.name,
                    email: r.email,
                    image: r.picture,
                    emailVerified: r.email_verified,
                    ...n
                },
                data: r
            };
        }
    });
;
var Ut = (e)=>{
    let t = e.tenantId || "common", r = `https://login.microsoftonline.com/${t}/oauth2/v2.0/authorize`, n = `https://login.microsoftonline.com/${t}/oauth2/v2.0/token`;
    return {
        id: "microsoft",
        name: "Microsoft EntraID",
        createAuthorizationURL (o) {
            let i = o.scopes || [
                "openid",
                "profile",
                "email",
                "User.Read"
            ];
            return e.scope && i.push(...e.scope), O({
                id: "microsoft",
                options: e,
                authorizationEndpoint: r,
                state: o.state,
                codeVerifier: o.codeVerifier,
                scopes: i,
                redirectURI: o.redirectURI
            });
        },
        validateAuthorizationCode ({ code: o, codeVerifier: i, redirectURI: d }) {
            return U({
                code: o,
                codeVerifier: i,
                redirectURI: e.redirectURI || d,
                options: e,
                tokenEndpoint: n
            });
        },
        async getUserInfo (o) {
            if (e.getUserInfo) return e.getUserInfo(o);
            if (!o.idToken) return null;
            let i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$util$2f$decode_jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeJwt"])(o.idToken), d = e.profilePhotoSize || 48;
            await v(`https://graph.microsoft.com/v1.0/me/photos/${d}x${d}/$value`, {
                headers: {
                    Authorization: `Bearer ${o.accessToken}`
                },
                async onResponse (s) {
                    if (!(e.disableProfilePhoto || !s.response.ok)) try {
                        let c = await s.response.clone().arrayBuffer(), p = Buffer.from(c).toString("base64");
                        i.picture = `data:image/jpeg;base64, ${p}`;
                    } catch (a) {
                        C.error(a && typeof a == "object" && "name" in a ? a.name : "", a);
                    }
                }
            });
            let l = await e.mapProfileToUser?.(i);
            return {
                user: {
                    id: i.sub,
                    name: i.name,
                    email: i.email,
                    image: i.picture,
                    emailVerified: !0,
                    ...l
                },
                data: i
            };
        }
    };
};
var Ot = (e)=>({
        id: "spotify",
        name: "Spotify",
        createAuthorizationURL ({ state: t, scopes: r, codeVerifier: n, redirectURI: o }) {
            let i = r || [
                "user-read-email"
            ];
            return e.scope && i.push(...e.scope), O({
                id: "spotify",
                options: e,
                authorizationEndpoint: "https://accounts.spotify.com/authorize",
                scopes: i,
                state: t,
                codeVerifier: n,
                redirectURI: o
            });
        },
        validateAuthorizationCode: async ({ code: t, codeVerifier: r, redirectURI: n })=>U({
                code: t,
                codeVerifier: r,
                redirectURI: e.redirectURI || n,
                options: e,
                tokenEndpoint: "https://accounts.spotify.com/api/token"
            }),
        async getUserInfo (t) {
            if (e.getUserInfo) return e.getUserInfo(t);
            let { data: r, error: n } = await v("https://api.spotify.com/v1/me", {
                method: "GET",
                headers: {
                    Authorization: `Bearer ${t.accessToken}`
                }
            });
            if (n) return null;
            let o = await e.mapProfileToUser?.(r);
            return {
                user: {
                    id: r.id,
                    name: r.display_name,
                    email: r.email,
                    image: r.images[0]?.url,
                    emailVerified: !1,
                    ...o
                },
                data: r
            };
        }
    });
function Yi(e) {
    return e.charAt(0).toUpperCase() + e.slice(1);
}
var se = {
    isAction: !1
};
;
var H = (e)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$random$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createRandomStringGenerator"])("a-z", "A-Z", "0-9")(e || 32);
;
var xt = (e)=>({
        id: "twitch",
        name: "Twitch",
        createAuthorizationURL ({ state: t, scopes: r, redirectURI: n }) {
            let o = r || [
                "user:read:email",
                "openid"
            ];
            return e.scope && o.push(...e.scope), O({
                id: "twitch",
                redirectURI: n,
                options: e,
                authorizationEndpoint: "https://id.twitch.tv/oauth2/authorize",
                scopes: o,
                state: t,
                claims: e.claims || [
                    "email",
                    "email_verified",
                    "preferred_username",
                    "picture"
                ]
            });
        },
        validateAuthorizationCode: async ({ code: t, redirectURI: r })=>U({
                code: t,
                redirectURI: e.redirectURI || r,
                options: e,
                tokenEndpoint: "https://id.twitch.tv/oauth2/token"
            }),
        async getUserInfo (t) {
            if (e.getUserInfo) return e.getUserInfo(t);
            let r = t.idToken;
            if (!r) return C.error("No idToken found in token"), null;
            let n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$util$2f$decode_jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeJwt"])(r), o = await e.mapProfileToUser?.(n);
            return {
                user: {
                    id: n.sub,
                    name: n.preferred_username,
                    email: n.email,
                    image: n.picture,
                    emailVerified: !1,
                    ...o
                },
                data: n
            };
        }
    });
var St = (e)=>({
        id: "twitter",
        name: "Twitter",
        createAuthorizationURL (t) {
            let r = t.scopes || [
                "users.read",
                "tweet.read",
                "offline.access"
            ];
            return e.scope && r.push(...e.scope), O({
                id: "twitter",
                options: e,
                authorizationEndpoint: "https://x.com/i/oauth2/authorize",
                scopes: r,
                state: t.state,
                codeVerifier: t.codeVerifier,
                redirectURI: t.redirectURI
            });
        },
        validateAuthorizationCode: async ({ code: t, codeVerifier: r, redirectURI: n })=>U({
                code: t,
                codeVerifier: r,
                authentication: "basic",
                redirectURI: e.redirectURI || n,
                options: e,
                tokenEndpoint: "https://api.x.com/2/oauth2/token"
            }),
        async getUserInfo (t) {
            if (e.getUserInfo) return e.getUserInfo(t);
            let { data: r, error: n } = await v("https://api.x.com/2/users/me?user.fields=profile_image_url", {
                method: "GET",
                headers: {
                    Authorization: `Bearer ${t.accessToken}`
                }
            });
            if (n) return null;
            let o = await e.mapProfileToUser?.(r);
            return {
                user: {
                    id: r.data.id,
                    name: r.data.name,
                    email: r.data.username || null,
                    image: r.data.profile_image_url,
                    emailVerified: r.data.verified || !1,
                    ...o
                },
                data: r
            };
        }
    });
var _t = (e)=>{
    let t = "https://api.dropboxapi.com/oauth2/token";
    return {
        id: "dropbox",
        name: "Dropbox",
        createAuthorizationURL: async ({ state: r, scopes: n, codeVerifier: o, redirectURI: i })=>{
            let d = n || [
                "account_info.read"
            ];
            return e.scope && d.push(...e.scope), await O({
                id: "dropbox",
                options: e,
                authorizationEndpoint: "https://www.dropbox.com/oauth2/authorize",
                scopes: d,
                state: r,
                redirectURI: i,
                codeVerifier: o
            });
        },
        validateAuthorizationCode: async ({ code: r, codeVerifier: n, redirectURI: o })=>await U({
                code: r,
                codeVerifier: n,
                redirectURI: e.redirectURI || o,
                options: e,
                tokenEndpoint: t
            }),
        async getUserInfo (r) {
            if (e.getUserInfo) return e.getUserInfo(r);
            let { data: n, error: o } = await v("https://api.dropboxapi.com/2/users/get_current_account", {
                method: "POST",
                headers: {
                    Authorization: `Bearer ${r.accessToken}`
                }
            });
            if (o) return null;
            let i = await e.mapProfileToUser?.(n);
            return {
                user: {
                    id: n.account_id,
                    name: n.name?.display_name,
                    email: n.email,
                    emailVerified: n.email_verified || !1,
                    image: n.profile_photo_url,
                    ...i
                },
                data: n
            };
        }
    };
};
var It = (e)=>{
    let t = "https://www.linkedin.com/oauth/v2/authorization", r = "https://www.linkedin.com/oauth/v2/accessToken";
    return {
        id: "linkedin",
        name: "Linkedin",
        createAuthorizationURL: async ({ state: n, scopes: o, redirectURI: i })=>{
            let d = o || [
                "profile",
                "email",
                "openid"
            ];
            return e.scope && d.push(...e.scope), await O({
                id: "linkedin",
                options: e,
                authorizationEndpoint: t,
                scopes: d,
                state: n,
                redirectURI: i
            });
        },
        validateAuthorizationCode: async ({ code: n, redirectURI: o })=>await U({
                code: n,
                redirectURI: e.redirectURI || o,
                options: e,
                tokenEndpoint: r
            }),
        async getUserInfo (n) {
            let { data: o, error: i } = await v("https://api.linkedin.com/v2/userinfo", {
                method: "GET",
                headers: {
                    Authorization: `Bearer ${n.accessToken}`
                }
            });
            if (i) return null;
            let d = await e.mapProfileToUser?.(o);
            return {
                user: {
                    id: o.sub,
                    name: o.name,
                    email: o.email,
                    emailVerified: o.email_verified || !1,
                    image: o.picture,
                    ...d
                },
                data: o
            };
        }
    };
};
var Fe = (e = "")=>e.split("://").map((t)=>t.replace(/\/{2,}/g, "/")).join("://"), Rn = (e)=>{
    let t = e || "https://gitlab.com";
    return {
        authorizationEndpoint: Fe(`${t}/oauth/authorize`),
        tokenEndpoint: Fe(`${t}/oauth/token`),
        userinfoEndpoint: Fe(`${t}/api/v4/user`)
    };
}, Pt = (e)=>{
    let { authorizationEndpoint: t, tokenEndpoint: r, userinfoEndpoint: n } = Rn(e.issuer), o = "gitlab";
    return {
        id: o,
        name: "Gitlab",
        createAuthorizationURL: async ({ state: d, scopes: l, codeVerifier: s, redirectURI: a })=>{
            let c = l || [
                "read_user"
            ];
            return e.scope && c.push(...e.scope), await O({
                id: o,
                options: e,
                authorizationEndpoint: t,
                scopes: c,
                state: d,
                redirectURI: a,
                codeVerifier: s
            });
        },
        validateAuthorizationCode: async ({ code: d, redirectURI: l, codeVerifier: s })=>U({
                code: d,
                redirectURI: e.redirectURI || l,
                options: e,
                codeVerifier: s,
                tokenEndpoint: r
            }),
        async getUserInfo (d) {
            if (e.getUserInfo) return e.getUserInfo(d);
            let { data: l, error: s } = await v(n, {
                headers: {
                    authorization: `Bearer ${d.accessToken}`
                }
            });
            if (s || l.state !== "active" || l.locked) return null;
            let a = await e.mapProfileToUser?.(l);
            return {
                user: {
                    id: l.id.toString(),
                    name: l.name ?? l.username,
                    email: l.email,
                    image: l.avatar_url,
                    emailVerified: !0,
                    ...a
                },
                data: l
            };
        }
    };
};
var Lt = (e)=>({
        id: "reddit",
        name: "Reddit",
        createAuthorizationURL ({ state: t, scopes: r, redirectURI: n }) {
            let o = r || [
                "identity"
            ];
            return e.scope && o.push(...e.scope), O({
                id: "reddit",
                options: e,
                authorizationEndpoint: "https://www.reddit.com/api/v1/authorize",
                scopes: o,
                state: t,
                redirectURI: n,
                duration: e.duration
            });
        },
        validateAuthorizationCode: async ({ code: t, redirectURI: r })=>{
            let n = new URLSearchParams({
                grant_type: "authorization_code",
                code: t,
                redirect_uri: e.redirectURI || r
            }), o = {
                "content-type": "application/x-www-form-urlencoded",
                accept: "text/plain",
                "user-agent": "better-auth",
                Authorization: `Basic ${Buffer.from(`${e.clientId}:${e.clientSecret}`).toString("base64")}`
            }, { data: i, error: d } = await v("https://www.reddit.com/api/v1/access_token", {
                method: "POST",
                headers: o,
                body: n.toString()
            });
            if (d) throw d;
            return Ee(i);
        },
        async getUserInfo (t) {
            if (e.getUserInfo) return e.getUserInfo(t);
            let { data: r, error: n } = await v("https://oauth.reddit.com/api/v1/me", {
                headers: {
                    Authorization: `Bearer ${t.accessToken}`,
                    "User-Agent": "better-auth"
                }
            });
            if (n) return null;
            let o = await e.mapProfileToUser?.(r);
            return {
                user: {
                    id: r.id,
                    name: r.name,
                    email: r.oauth_client_id,
                    emailVerified: r.has_verified_email,
                    image: r.icon_img?.split("?")[0],
                    ...o
                },
                data: r
            };
        }
    });
;
var qe = {
    apple: Rt,
    discord: kt,
    facebook: Tt,
    github: Et,
    microsoft: Ut,
    google: vt,
    spotify: Ot,
    twitch: xt,
    twitter: St,
    dropbox: _t,
    linkedin: It,
    gitlab: Pt,
    reddit: Lt
}, Ve = Object.keys(qe), Dt = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].enum(Ve, {
    description: "OAuth2 provider to use"
});
;
;
;
;
function ae(e) {
    try {
        return JSON.parse(e);
    } catch  {
        return null;
    }
}
var w = {
    USER_NOT_FOUND: "User not found",
    FAILED_TO_CREATE_USER: "Failed to create user",
    FAILED_TO_CREATE_SESSION: "Failed to create session",
    FAILED_TO_UPDATE_USER: "Failed to update user",
    FAILED_TO_GET_SESSION: "Failed to get session",
    INVALID_PASSWORD: "Invalid password",
    INVALID_EMAIL: "Invalid email",
    INVALID_EMAIL_OR_PASSWORD: "Invalid email or password",
    SOCIAL_ACCOUNT_ALREADY_LINKED: "Social account already linked",
    PROVIDER_NOT_FOUND: "Provider not found",
    INVALID_TOKEN: "invalid token",
    ID_TOKEN_NOT_SUPPORTED: "id_token not supported",
    FAILED_TO_GET_USER_INFO: "Failed to get user info",
    USER_EMAIL_NOT_FOUND: "User email not found",
    EMAIL_NOT_VERIFIED: "Email not verified",
    PASSWORD_TOO_SHORT: "Password too short",
    PASSWORD_TOO_LONG: "Password too long",
    USER_ALREADY_EXISTS: "User already exists",
    EMAIL_CAN_NOT_BE_UPDATED: "Email can not be updated",
    CREDENTIAL_ACCOUNT_NOT_FOUND: "Credential account not found",
    SESSION_EXPIRED: "Session expired. Re-authenticate to perform this action."
};
;
;
;
var $e = ()=>E("/get-session", {
        method: "GET",
        query: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
            disableCookieCache: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].boolean({
                description: "Disable cookie cache and fetch session from database"
            }).or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().transform((e)=>e === "true")).optional(),
            disableRefresh: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].boolean({
                description: "Disable session refresh. Useful for checking session status, without updating the session"
            }).optional()
        })),
        requireHeaders: !0,
        metadata: {
            openapi: {
                description: "Get the current session",
                responses: {
                    200: {
                        description: "Success",
                        content: {
                            "application/json": {
                                schema: {
                                    type: "object",
                                    properties: {
                                        session: {
                                            type: "object",
                                            properties: {
                                                token: {
                                                    type: "string"
                                                },
                                                userId: {
                                                    type: "string"
                                                },
                                                expiresAt: {
                                                    type: "string"
                                                }
                                            }
                                        },
                                        user: {
                                            type: "object",
                                            $ref: "#/components/schemas/User"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }, async (e)=>{
        try {
            let t = await e.getSignedCookie(e.context.authCookies.sessionToken.name, e.context.secret);
            if (!t) return e.json(null);
            let r = e.getCookie(e.context.authCookies.sessionData.name), n = r ? ae(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$binary$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["binary"].decode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$base64$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["base64"].decode(r))) : null;
            if (n && !await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hmac$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createHMAC"])("SHA-256", "base64urlnopad").verify(e.context.secret, JSON.stringify(n.session), n.signature)) return M(e), e.json(null);
            let o = await e.getSignedCookie(e.context.authCookies.dontRememberToken.name, e.context.secret);
            if (n?.session && e.context.options.session?.cookieCache?.enabled && !e.query?.disableCookieCache) {
                let c = n.session;
                if (n.expiresAt < Date.now() || c.session.expiresAt < new Date) {
                    let m = e.context.authCookies.sessionData.name;
                    e.setCookie(m, "", {
                        maxAge: 0
                    });
                } else return e.json(c);
            }
            let i = await e.context.internalAdapter.findSession(t);
            if (e.context.session = i, !i || i.session.expiresAt < new Date) return M(e), i && await e.context.internalAdapter.deleteSession(i.session.token), e.json(null);
            if (o || e.query?.disableRefresh) return e.json(i);
            let d = e.context.sessionConfig.expiresIn, l = e.context.sessionConfig.updateAge;
            if (i.session.expiresAt.valueOf() - d * 1e3 + l * 1e3 <= Date.now()) {
                let c = await e.context.internalAdapter.updateSession(i.session.token, {
                    expiresAt: V(e.context.sessionConfig.expiresIn, "sec")
                });
                if (!c) return M(e), e.json(null, {
                    status: 401
                });
                let p = (c.expiresAt.valueOf() - Date.now()) / 1e3;
                return await D(e, {
                    session: c,
                    user: i.user
                }, !1, {
                    maxAge: p
                }), e.json({
                    session: c,
                    user: i.user
                });
            }
            return await Be(e, i), e.json(i);
        } catch (t) {
            throw e.context.logger.error("INTERNAL_SERVER_ERROR", t), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("INTERNAL_SERVER_ERROR", {
                message: w.FAILED_TO_GET_SESSION
            });
        }
    }), oe = async (e, t)=>{
    if (e.context.session) return e.context.session;
    let r = await $e()({
        ...e,
        _flag: "json",
        headers: e.headers,
        query: t
    }).catch((n)=>null);
    return e.context.session = r, r;
}, j = ce(async (e)=>{
    let t = await oe(e);
    if (!t?.session) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED");
    return {
        session: t
    };
}), ha = ce(async (e)=>{
    let t = await oe(e);
    if (!t?.session) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED");
    if (e.context.sessionConfig.freshAge === 0) return {
        session: t
    };
    let r = e.context.sessionConfig.freshAge, n = t.session.updatedAt?.valueOf() || t.session.createdAt.valueOf();
    if (!(Date.now() - n < r * 1e3)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("FORBIDDEN", {
        message: "Session is not fresh"
    });
    return {
        session: t
    };
}), Ct = ()=>E("/list-sessions", {
        method: "GET",
        use: [
            j
        ],
        requireHeaders: !0,
        metadata: {
            openapi: {
                description: "List all active sessions for the user",
                responses: {
                    200: {
                        description: "Success",
                        content: {
                            "application/json": {
                                schema: {
                                    type: "array",
                                    items: {
                                        type: "object",
                                        properties: {
                                            token: {
                                                type: "string"
                                            },
                                            userId: {
                                                type: "string"
                                            },
                                            expiresAt: {
                                                type: "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }, async (e)=>{
        let r = (await e.context.internalAdapter.listSessions(e.context.session.user.id)).filter((n)=>n.expiresAt > new Date);
        return e.json(r);
    }), Nt = E("/revoke-session", {
    method: "POST",
    body: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        token: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The token to revoke"
        })
    }),
    use: [
        j
    ],
    requireHeaders: !0,
    metadata: {
        openapi: {
            description: "Revoke a single session",
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            type: "object",
                            properties: {
                                token: {
                                    type: "string"
                                }
                            },
                            required: [
                                "token"
                            ]
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    let t = e.body.token, r = await e.context.internalAdapter.findSession(t);
    if (!r) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "Session not found"
    });
    if (r.session.userId !== e.context.session.user.id) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED");
    try {
        await e.context.internalAdapter.deleteSession(t);
    } catch (n) {
        throw e.context.logger.error(n && typeof n == "object" && "name" in n ? n.name : "", n), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("INTERNAL_SERVER_ERROR");
    }
    return e.json({
        status: !0
    });
}), Bt = E("/revoke-sessions", {
    method: "POST",
    use: [
        j
    ],
    requireHeaders: !0,
    metadata: {
        openapi: {
            description: "Revoke all sessions for the user",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    status: {
                                        type: "boolean"
                                    }
                                },
                                required: [
                                    "status"
                                ]
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    try {
        await e.context.internalAdapter.deleteSessions(e.context.session.user.id);
    } catch (t) {
        throw e.context.logger.error(t && typeof t == "object" && "name" in t ? t.name : "", t), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("INTERNAL_SERVER_ERROR");
    }
    return e.json({
        status: !0
    });
}), jt = E("/revoke-other-sessions", {
    method: "POST",
    requireHeaders: !0,
    use: [
        j
    ],
    metadata: {
        openapi: {
            description: "Revoke all other sessions for the user except the current one",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    status: {
                                        type: "boolean"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    let t = e.context.session;
    if (!t.user) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED");
    let o = (await e.context.internalAdapter.listSessions(t.user.id)).filter((i)=>i.expiresAt > new Date).filter((i)=>i.token !== e.context.session.session.token);
    return await Promise.all(o.map((i)=>e.context.internalAdapter.deleteSession(i.token))), e.json({
        status: !0
    });
});
;
;
async function Ft(e, t, r = 3600) {
    return await new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwt$2f$sign$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SignJWT"](e).setProtectedHeader({
        alg: "HS256"
    }).setIssuedAt().setExpirationTime(Math.floor(Date.now() / 1e3) + r).sign(new TextEncoder().encode(t));
}
async function W(e, t, r) {
    return await Ft({
        email: t.toLowerCase(),
        updateTo: r
    }, e);
}
async function xn(e, t) {
    if (!e.context.options.emailVerification?.sendVerificationEmail) throw e.context.logger.error("Verification email isn't enabled."), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "Verification email isn't enabled"
    });
    let r = await W(e.context.secret, t.email), n = `${e.context.baseURL}/verify-email?token=${r}&callbackURL=${e.body.callbackURL || e.query?.currentURL || "/"}`;
    await e.context.options.emailVerification.sendVerificationEmail({
        user: t,
        url: n,
        token: r
    }, e.request);
}
var qt = E("/send-verification-email", {
    method: "POST",
    query: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        currentURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The URL to use for email verification callback"
        }).optional()
    }).optional(),
    body: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        email: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The email to send the verification email to"
        }).email(),
        callbackURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The URL to use for email verification callback"
        }).optional()
    }),
    metadata: {
        openapi: {
            description: "Send a verification email to the user",
            requestBody: {
                content: {
                    "application/json": {
                        schema: {
                            type: "object",
                            properties: {
                                email: {
                                    type: "string",
                                    description: "The email to send the verification email to"
                                },
                                callbackURL: {
                                    type: "string",
                                    description: "The URL to use for email verification callback"
                                }
                            },
                            required: [
                                "email"
                            ]
                        }
                    }
                }
            },
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    status: {
                                        type: "boolean"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    if (!e.context.options.emailVerification?.sendVerificationEmail) throw e.context.logger.error("Verification email isn't enabled."), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "Verification email isn't enabled"
    });
    let { email: t } = e.body, r = await e.context.internalAdapter.findUserByEmail(t);
    if (!r) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.USER_NOT_FOUND
    });
    return await xn(e, r.user), e.json({
        status: !0
    });
}), Vt = E("/verify-email", {
    method: "GET",
    query: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        token: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The token to verify the email"
        }),
        callbackURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The URL to redirect to after email verification"
        }).optional()
    }),
    metadata: {
        openapi: {
            description: "Verify the email of the user",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    user: {
                                        type: "object"
                                    },
                                    status: {
                                        type: "boolean"
                                    }
                                },
                                required: [
                                    "user",
                                    "status"
                                ]
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    function t(l) {
        throw e.query.callbackURL ? e.query.callbackURL.includes("?") ? e.redirect(`${e.query.callbackURL}&error=${l}`) : e.redirect(`${e.query.callbackURL}?error=${l}`) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED", {
            message: l
        });
    }
    let { token: r } = e.query, n;
    try {
        n = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$node$2f$esm$2f$jwt$2f$verify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jwtVerify"])(r, new TextEncoder().encode(e.context.secret), {
            algorithms: [
                "HS256"
            ]
        });
    } catch (l) {
        return e.context.logger.error("Failed to verify email", l), t("invalid_token");
    }
    let i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        email: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().email(),
        updateTo: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional()
    }).parse(n.payload), d = await e.context.internalAdapter.findUserByEmail(i.email);
    if (!d) return t("user_not_found");
    if (i.updateTo) {
        let l = await oe(e);
        if (!l) {
            if (e.query.callbackURL) throw e.redirect(`${e.query.callbackURL}?error=unauthorized`);
            return t("unauthorized");
        }
        if (l.user.email !== i.email) {
            if (e.query.callbackURL) throw e.redirect(`${e.query.callbackURL}?error=unauthorized`);
            return t("unauthorized");
        }
        let s = await e.context.internalAdapter.updateUserByEmail(i.email, {
            email: i.updateTo,
            emailVerified: !1
        }), a = await W(e.context.secret, i.updateTo);
        if (await e.context.options.emailVerification?.sendVerificationEmail?.({
            user: s,
            url: `${e.context.baseURL}/verify-email?token=${a}`,
            token: a
        }, e.request), e.query.callbackURL) throw e.redirect(e.query.callbackURL);
        return e.json({
            status: !0
        });
    }
    if (await e.context.internalAdapter.updateUserByEmail(i.email, {
        emailVerified: !0
    }), e.context.options.emailVerification?.autoSignInAfterVerification) {
        let l = await oe(e);
        if (!l || l.user.email !== i.email) {
            let s = await e.context.internalAdapter.createSession(d.user.id, e.request);
            if (!s) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("INTERNAL_SERVER_ERROR", {
                message: "Failed to create session"
            });
            await D(e, {
                session: s,
                user: d.user
            });
        }
    }
    if (e.query.callbackURL) throw e.redirect(e.query.callbackURL);
    return e.json({
        status: !0
    });
});
async function Oe(e, { userInfo: t, account: r, callbackURL: n }) {
    let o = await e.context.internalAdapter.findOAuthUser(t.email.toLowerCase(), r.accountId, r.providerId).catch((s)=>{
        throw C.error(`Better auth was unable to query your database.
Error: `, s), e.redirect(`${e.context.baseURL}/error?error=internal_server_error`);
    }), i = o?.user, d = !i;
    if (o) {
        let s = o.accounts.find((a)=>a.providerId === r.providerId);
        if (s) {
            let a = Object.fromEntries(Object.entries({
                accessToken: r.accessToken,
                idToken: r.idToken,
                refreshToken: r.refreshToken,
                accessTokenExpiresAt: r.accessTokenExpiresAt,
                refreshTokenExpiresAt: r.refreshTokenExpiresAt
            }).filter(([c, p])=>p !== void 0));
            Object.keys(a).length > 0 && await e.context.internalAdapter.updateAccount(s.id, a);
        } else {
            if (!e.context.options.account?.accountLinking?.trustedProviders?.includes(r.providerId) && !t.emailVerified || e.context.options.account?.accountLinking?.enabled === !1) return Te && C.warn(`User already exist but account isn't linked to ${r.providerId}. To read more about how account linking works in Better Auth see https://www.better-auth.com/docs/concepts/users-accounts#account-linking.`), {
                error: "account not linked",
                data: null
            };
            try {
                await e.context.internalAdapter.linkAccount({
                    providerId: r.providerId,
                    accountId: t.id.toString(),
                    userId: o.user.id,
                    accessToken: r.accessToken,
                    idToken: r.idToken,
                    refreshToken: r.refreshToken,
                    accessTokenExpiresAt: r.accessTokenExpiresAt,
                    refreshTokenExpiresAt: r.refreshTokenExpiresAt,
                    scope: r.scope
                });
            } catch (p) {
                return C.error("Unable to link account", p), {
                    error: "unable to link account",
                    data: null
                };
            }
        }
    } else try {
        if (i = await e.context.internalAdapter.createOAuthUser({
            ...t,
            email: t.email.toLowerCase(),
            id: void 0
        }, {
            accessToken: r.accessToken,
            idToken: r.idToken,
            refreshToken: r.refreshToken,
            accessTokenExpiresAt: r.accessTokenExpiresAt,
            refreshTokenExpiresAt: r.refreshTokenExpiresAt,
            scope: r.scope,
            providerId: r.providerId,
            accountId: t.id.toString()
        }).then((s)=>s?.user), !t.emailVerified && i && e.context.options.emailVerification?.sendOnSignUp) {
            let s = await W(e.context.secret, i.email), a = `${e.context.baseURL}/verify-email?token=${s}&callbackURL=${n}`;
            await e.context.options.emailVerification?.sendVerificationEmail?.({
                user: i,
                url: a,
                token: s
            }, e.request);
        }
    } catch (s) {
        return s instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"] ? {
            error: s.message,
            data: null,
            isRegister: !1
        } : {
            error: "unable to create user",
            data: null,
            isRegister: !1
        };
    }
    if (!i) return {
        error: "unable to create user",
        data: null,
        isRegister: !1
    };
    let l = await e.context.internalAdapter.createSession(i.id, e.request);
    return l ? {
        data: {
            session: l,
            user: i
        },
        error: null,
        isRegister: d
    } : {
        error: "unable to create session",
        data: null,
        isRegister: !1
    };
}
var Mt = E("/sign-in/social", {
    method: "POST",
    query: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        currentURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional()
    }).optional(),
    body: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        callbackURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "Callback URL to redirect to after the user has signed in"
        }).optional(),
        newUserCallbackURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional(),
        errorCallbackURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "Callback URL to redirect to if an error happens"
        }).optional(),
        provider: Dt,
        disableRedirect: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].boolean({
            description: "Disable automatic redirection to the provider. Useful for handling the redirection yourself"
        }).optional(),
        idToken: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
            token: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
                description: "ID token from the provider"
            }),
            nonce: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
                description: "Nonce used to generate the token"
            }).optional(),
            accessToken: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
                description: "Access token from the provider"
            }).optional(),
            refreshToken: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
                description: "Refresh token from the provider"
            }).optional(),
            expiresAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].number({
                description: "Expiry date of the token"
            }).optional()
        }), {
            description: "ID token from the provider to sign in the user with id token"
        })
    }),
    metadata: {
        openapi: {
            description: "Sign in with a social provider",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    session: {
                                        type: "string"
                                    },
                                    user: {
                                        type: "object"
                                    },
                                    url: {
                                        type: "string"
                                    },
                                    redirect: {
                                        type: "boolean"
                                    }
                                },
                                required: [
                                    "session",
                                    "user",
                                    "url",
                                    "redirect"
                                ]
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    let t = e.context.socialProviders.find((i)=>i.id === e.body.provider);
    if (!t) throw e.context.logger.error("Provider not found. Make sure to add the provider in your auth config", {
        provider: e.body.provider
    }), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("NOT_FOUND", {
        message: w.PROVIDER_NOT_FOUND
    });
    if (e.body.idToken) {
        if (!t.verifyIdToken) throw e.context.logger.error("Provider does not support id token verification", {
            provider: e.body.provider
        }), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("NOT_FOUND", {
            message: w.ID_TOKEN_NOT_SUPPORTED
        });
        let { token: i, nonce: d } = e.body.idToken;
        if (!await t.verifyIdToken(i, d)) throw e.context.logger.error("Invalid id token", {
            provider: e.body.provider
        }), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED", {
            message: w.INVALID_TOKEN
        });
        let s = await t.getUserInfo({
            idToken: i,
            accessToken: e.body.idToken.accessToken,
            refreshToken: e.body.idToken.refreshToken
        });
        if (!s || !s?.user) throw e.context.logger.error("Failed to get user info", {
            provider: e.body.provider
        }), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED", {
            message: w.FAILED_TO_GET_USER_INFO
        });
        if (!s.user.email) throw e.context.logger.error("User email not found", {
            provider: e.body.provider
        }), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED", {
            message: w.USER_EMAIL_NOT_FOUND
        });
        let a = await Oe(e, {
            userInfo: {
                email: s.user.email,
                id: s.user.id,
                name: s.user.name || "",
                image: s.user.image,
                emailVerified: s.user.emailVerified || !1
            },
            account: {
                providerId: t.id,
                accountId: s.user.id,
                accessToken: e.body.idToken.accessToken
            }
        });
        if (a.error) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED", {
            message: a.error
        });
        return await D(e, a.data), e.json({
            token: a.data.session.token,
            url: void 0,
            redirect: !1
        });
    }
    let { codeVerifier: r, state: n } = await ve(e), o = await t.createAuthorizationURL({
        state: n,
        codeVerifier: r,
        redirectURI: `${e.context.baseURL}/callback/${t.id}`
    });
    return e.json({
        url: o.toString(),
        redirect: !e.body.disableRedirect
    });
}), zt = E("/sign-in/email", {
    method: "POST",
    body: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        email: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "Email of the user"
        }),
        password: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "Password of the user"
        }),
        callbackURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "Callback URL to use as a redirect for email verification"
        }).optional(),
        rememberMe: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].boolean({
            description: "If this is false, the session will not be remembered. Default is `true`."
        }).default(!0).optional()
    }),
    metadata: {
        openapi: {
            description: "Sign in with email and password",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    user: {
                                        type: "object"
                                    },
                                    url: {
                                        type: "string"
                                    },
                                    redirect: {
                                        type: "boolean"
                                    }
                                },
                                required: [
                                    "session",
                                    "user",
                                    "url",
                                    "redirect"
                                ]
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    if (!e.context.options?.emailAndPassword?.enabled) throw e.context.logger.error("Email and password is not enabled. Make sure to enable it in the options on you `auth.ts` file. Check `https://better-auth.com/docs/authentication/email-password` for more!"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "Email and password is not enabled"
    });
    let { email: t, password: r } = e.body;
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().email().safeParse(t).success) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.INVALID_EMAIL
    });
    let o = await e.context.internalAdapter.findUserByEmail(t, {
        includeAccounts: !0
    });
    if (!o) throw await e.context.password.hash(r), e.context.logger.error("User not found", {
        email: t
    }), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED", {
        message: w.INVALID_EMAIL_OR_PASSWORD
    });
    let i = o.accounts.find((a)=>a.providerId === "credential");
    if (!i) throw e.context.logger.error("Credential account not found", {
        email: t
    }), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED", {
        message: w.INVALID_EMAIL_OR_PASSWORD
    });
    let d = i?.password;
    if (!d) throw e.context.logger.error("Password not found", {
        email: t
    }), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED", {
        message: w.INVALID_EMAIL_OR_PASSWORD
    });
    if (!await e.context.password.verify({
        hash: d,
        password: r
    })) throw e.context.logger.error("Invalid password"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED", {
        message: w.INVALID_EMAIL_OR_PASSWORD
    });
    if (e.context.options?.emailAndPassword?.requireEmailVerification && !o.user.emailVerified) {
        if (!e.context.options?.emailVerification?.sendVerificationEmail) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED", {
            message: w.EMAIL_NOT_VERIFIED
        });
        let a = await W(e.context.secret, o.user.email), c = `${e.context.baseURL}/verify-email?token=${a}&callbackURL=${e.body.callbackURL || "/"}`;
        throw await e.context.options.emailVerification.sendVerificationEmail({
            user: o.user,
            url: c,
            token: a
        }, e.request), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("FORBIDDEN", {
            message: w.EMAIL_NOT_VERIFIED
        });
    }
    let s = await e.context.internalAdapter.createSession(o.user.id, e.headers, e.body.rememberMe === !1);
    if (!s) throw e.context.logger.error("Failed to create session"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNAUTHORIZED", {
        message: w.FAILED_TO_CREATE_SESSION
    });
    return await D(e, {
        session: s,
        user: o.user
    }, e.body.rememberMe === !1), e.json({
        user: {
            id: o.user.id,
            email: o.user.email,
            name: o.user.name,
            image: o.user.image,
            emailVerified: o.user.emailVerified,
            createdAt: o.user.createdAt,
            updatedAt: o.user.updatedAt
        },
        redirect: !!e.body.callbackURL,
        url: e.body.callbackURL
    });
});
;
var xe = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
    code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional(),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional(),
    error_description: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional(),
    state: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional()
}), Ht = E("/callback/:id", {
    method: [
        "GET",
        "POST"
    ],
    body: xe.optional(),
    query: xe.optional(),
    metadata: se
}, async (e)=>{
    let t;
    try {
        if (e.method === "GET") t = xe.parse(e.query);
        else if (e.method === "POST") t = xe.parse(e.body);
        else throw new Error("Unsupported method");
    } catch (h) {
        throw e.context.logger.error("INVALID_CALLBACK_REQUEST", h), e.redirect(`${e.context.baseURL}/error?error=invalid_callback_request`);
    }
    let { code: r, error: n, state: o, error_description: i } = t;
    if (!o) throw e.context.logger.error("State not found", n), e.redirect(`${e.context.baseURL}/error?error=state_not_found`);
    if (!r) throw e.context.logger.error("Code not found"), e.redirect(`${e.context.baseURL}/error?error=${n || "no_code"}&error_description=${i}`);
    let d = e.context.socialProviders.find((h)=>h.id === e.params.id);
    if (!d) throw e.context.logger.error("Oauth provider with id", e.params.id, "not found"), e.redirect(`${e.context.baseURL}/error?error=oauth_provider_not_found`);
    let { codeVerifier: l, callbackURL: s, link: a, errorURL: c, newUserURL: p } = await At(e), m;
    try {
        m = await d.validateAuthorizationCode({
            code: r,
            codeVerifier: l,
            redirectURI: `${e.context.baseURL}/callback/${d.id}`
        });
    } catch (h) {
        throw e.context.logger.error("", h), e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`);
    }
    let u = await d.getUserInfo(m).then((h)=>h?.user);
    function f(h) {
        let y = c || s || `${e.context.baseURL}/error`;
        throw y.includes("?") ? y = `${y}&error=${h}` : y = `${y}?error=${h}`, e.redirect(y);
    }
    if (!u) return e.context.logger.error("Unable to get user info"), f("unable_to_get_user_info");
    if (!u.email) return e.context.logger.error("Provider did not return email. This could be due to misconfiguration in the provider settings."), f("email_not_found");
    if (!s) throw e.context.logger.error("No callback URL found"), e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`);
    if (a) {
        if (a.email !== u.email.toLowerCase()) return f("email_doesn't_match");
        if (!await e.context.internalAdapter.createAccount({
            userId: a.userId,
            providerId: d.id,
            accountId: u.id
        })) return f("unable_to_link_account");
        let y;
        try {
            y = s.toString();
        } catch  {
            y = s;
        }
        throw e.redirect(y);
    }
    let g = await Oe(e, {
        userInfo: {
            ...u,
            email: u.email,
            name: u.name || u.email
        },
        account: {
            providerId: d.id,
            accountId: u.id,
            ...m,
            scope: m.scopes?.join(",")
        },
        callbackURL: s
    });
    if (g.error) return e.context.logger.error(g.error.split(" ").join("_")), f(g.error.split(" ").join("_"));
    let { session: b, user: A } = g.data;
    await D(e, {
        session: b,
        user: A
    });
    let R;
    try {
        R = (g.isRegister && p || s).toString();
    } catch  {
        R = g.isRegister && p || s;
    }
    throw e.redirect(R);
});
;
;
var Wt = E("/sign-out", {
    method: "POST",
    requireHeaders: !0,
    metadata: {
        openapi: {
            description: "Sign out the current user",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    success: {
                                        type: "boolean"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    let t = await e.getSignedCookie(e.context.authCookies.sessionToken.name, e.context.secret);
    if (!t) throw M(e), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.FAILED_TO_GET_SESSION
    });
    return await e.context.internalAdapter.deleteSession(t), M(e), e.json({
        success: !0
    });
});
;
;
function Gt(e, t, r) {
    let n = t ? new URL(t, e.baseURL) : new URL(`${e.baseURL}/error`);
    return r && Object.entries(r).forEach(([o, i])=>n.searchParams.set(o, i)), n.href;
}
function _n(e, t, r) {
    let n = new URL(t, e.baseURL);
    return r && Object.entries(r).forEach(([o, i])=>n.searchParams.set(o, i)), n.href;
}
var Kt = E("/forget-password", {
    method: "POST",
    body: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        email: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The email address of the user to send a password reset email to"
        }).email(),
        redirectTo: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter `?error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN"
        }).optional()
    }),
    metadata: {
        openapi: {
            description: "Send a password reset email to the user",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    status: {
                                        type: "boolean"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    if (!e.context.options.emailAndPassword?.sendResetPassword) throw e.context.logger.error("Reset password isn't enabled.Please pass an emailAndPassword.sendResetPasswordToken function in your auth config!"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "Reset password isn't enabled"
    });
    let { email: t, redirectTo: r } = e.body, n = await e.context.internalAdapter.findUserByEmail(t, {
        includeAccounts: !0
    });
    if (!n) return e.context.logger.error("Reset Password: User not found", {
        email: t
    }), e.json({
        status: !1
    }, {
        body: {
            status: !0
        }
    });
    let o = 60 * 60 * 1, i = V(e.context.options.emailAndPassword.resetPasswordTokenExpiresIn || o, "sec"), d = H(24);
    await e.context.internalAdapter.createVerificationValue({
        value: n.user.id.toString(),
        identifier: `reset-password:${d}`,
        expiresAt: i
    });
    let l = `${e.context.baseURL}/reset-password/${d}?callbackURL=${r}`;
    return await e.context.options.emailAndPassword.sendResetPassword({
        user: n.user,
        url: l,
        token: d
    }, e.request), e.json({
        status: !0
    });
}), Qt = E("/reset-password/:token", {
    method: "GET",
    query: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        callbackURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The URL to redirect the user to reset their password"
        })
    }),
    metadata: {
        openapi: {
            description: "Redirects the user to the callback URL with the token",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    token: {
                                        type: "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    let { token: t } = e.params, { callbackURL: r } = e.query;
    if (!t || !r) throw e.redirect(Gt(e.context, r, {
        error: "INVALID_TOKEN"
    }));
    let n = await e.context.internalAdapter.findVerificationValue(`reset-password:${t}`);
    throw !n || n.expiresAt < new Date ? e.redirect(Gt(e.context, r, {
        error: "INVALID_TOKEN"
    })) : e.redirect(_n(e.context, r, {
        token: t
    }));
}), Jt = E("/reset-password", {
    query: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        token: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional(),
        currentURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional()
    })),
    method: "POST",
    body: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        newPassword: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The new password to set"
        }),
        token: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The token to reset the password"
        }).optional()
    }),
    metadata: {
        openapi: {
            description: "Reset the password for a user",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    status: {
                                        type: "boolean"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    let t = e.body.token || e.query?.token || (e.query?.currentURL ? new URL(e.query.currentURL).searchParams.get("token") : "");
    if (!t) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.INVALID_TOKEN
    });
    let { newPassword: r } = e.body, n = e.context.password?.config.minPasswordLength, o = e.context.password?.config.maxPasswordLength;
    if (r.length < n) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.PASSWORD_TOO_SHORT
    });
    if (r.length > o) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.PASSWORD_TOO_LONG
    });
    let i = `reset-password:${t}`, d = await e.context.internalAdapter.findVerificationValue(i);
    if (!d || d.expiresAt < new Date) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.INVALID_TOKEN
    });
    await e.context.internalAdapter.deleteVerificationValue(d.id);
    let l = d.value, s = await e.context.password.hash(r);
    return (await e.context.internalAdapter.findAccounts(l)).find((p)=>p.providerId === "credential") ? (await e.context.internalAdapter.updatePassword(l, s), e.json({
        status: !0
    })) : (await e.context.internalAdapter.createAccount({
        userId: l,
        providerId: "credential",
        password: s,
        accountId: l
    }), e.json({
        status: !0
    }));
});
;
;
;
;
var pd = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    providerId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    accountId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    userId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    accessToken: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    refreshToken: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    idToken: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    accessTokenExpiresAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().nullish(),
    refreshTokenExpiresAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().nullish(),
    scope: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    password: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    createdAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date),
    updatedAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date)
}), fd = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    email: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().transform((e)=>e.toLowerCase()),
    emailVerified: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].boolean().default(!1),
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    image: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    createdAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date),
    updatedAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date)
}), md = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    userId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    expiresAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date(),
    createdAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date),
    updatedAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date),
    token: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    ipAddress: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    userAgent: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish()
}), gd = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    createdAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date),
    updatedAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date),
    expiresAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date(),
    identifier: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string()
});
function Zt(e, t) {
    let r = t.fields, n = {};
    for(let o in e){
        let i = r[o];
        if (!i) {
            n[o] = e[o];
            continue;
        }
        i.returned !== !1 && (n[o] = e[o]);
    }
    return n;
}
function Me(e, t) {
    let r = {
        ...t === "user" ? e.user?.additionalFields : {},
        ...t === "session" ? e.session?.additionalFields : {}
    };
    for (let n of e.plugins || [])n.schema && n.schema[t] && (r = {
        ...r,
        ...n.schema[t].fields
    });
    return r;
}
function ze(e, t) {
    let r = Me(e, "user");
    return Zt(t, {
        fields: r
    });
}
function Se(e, t) {
    let r = Me(e, "session");
    return Zt(t, {
        fields: r
    });
}
function Pn(e, t) {
    let r = t.action || "create", n = t.fields, o = {};
    for(let i in n){
        if (i in e) {
            if (n[i].input === !1) {
                if (n[i].defaultValue) {
                    o[i] = n[i].defaultValue;
                    continue;
                }
                continue;
            }
            if (n[i].validator?.input && e[i] !== void 0) {
                o[i] = n[i].validator.input.parse(e[i]);
                continue;
            }
            if (n[i].transform?.input && e[i] !== void 0) {
                o[i] = n[i].transform?.input(e[i]);
                continue;
            }
            o[i] = e[i];
            continue;
        }
        if (n[i].defaultValue && r === "create") {
            o[i] = n[i].defaultValue;
            continue;
        }
        if (n[i].required && r === "create") throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
            message: `${i} is required`
        });
    }
    return o;
}
function _e(e, t, r) {
    let n = Me(e, "user");
    return Pn(t || {}, {
        fields: n,
        action: r
    });
}
var Yt = ()=>E("/update-user", {
        method: "POST",
        body: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].any()),
        use: [
            j
        ],
        metadata: {
            openapi: {
                description: "Update the current user",
                requestBody: {
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    name: {
                                        type: "string",
                                        description: "The name of the user"
                                    },
                                    image: {
                                        type: "string",
                                        description: "The image of the user"
                                    }
                                }
                            }
                        }
                    }
                },
                responses: {
                    200: {
                        description: "Success",
                        content: {
                            "application/json": {
                                schema: {
                                    type: "object",
                                    properties: {
                                        user: {
                                            type: "object"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }, async (e)=>{
        let t = e.body;
        if (t.email) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
            message: w.EMAIL_CAN_NOT_BE_UPDATED
        });
        let { name: r, image: n, ...o } = t, i = e.context.session;
        if (n === void 0 && r === void 0 && Object.keys(o).length === 0) return e.json({
            status: !0
        });
        let d = _e(e.context.options, o, "update"), l = await e.context.internalAdapter.updateUserByEmail(i.user.email, {
            name: r,
            image: n,
            ...d
        });
        return await D(e, {
            session: i.session,
            user: l
        }), e.json({
            status: !0
        });
    }), Xt = E("/change-password", {
    method: "POST",
    body: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        newPassword: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The new password to set"
        }),
        currentPassword: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The current password"
        }),
        revokeOtherSessions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].boolean({
            description: "Revoke all other sessions"
        }).optional()
    }),
    use: [
        j
    ],
    metadata: {
        openapi: {
            description: "Change the password of the user",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    user: {
                                        description: "The user object",
                                        $ref: "#/components/schemas/User"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    let { newPassword: t, currentPassword: r, revokeOtherSessions: n } = e.body, o = e.context.session, i = e.context.password.config.minPasswordLength;
    if (t.length < i) throw e.context.logger.error("Password is too short"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.PASSWORD_TOO_SHORT
    });
    let d = e.context.password.config.maxPasswordLength;
    if (t.length > d) throw e.context.logger.error("Password is too long"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.PASSWORD_TOO_LONG
    });
    let s = (await e.context.internalAdapter.findAccounts(o.user.id)).find((m)=>m.providerId === "credential" && m.password);
    if (!s || !s.password) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.CREDENTIAL_ACCOUNT_NOT_FOUND
    });
    let a = await e.context.password.hash(t);
    if (!await e.context.password.verify({
        hash: s.password,
        password: r
    })) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.INVALID_PASSWORD
    });
    await e.context.internalAdapter.updateAccount(s.id, {
        password: a
    });
    let p = null;
    if (n) {
        await e.context.internalAdapter.deleteSessions(o.user.id);
        let m = await e.context.internalAdapter.createSession(o.user.id, e.headers);
        if (!m) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("INTERNAL_SERVER_ERROR", {
            message: w.FAILED_TO_GET_SESSION
        });
        await D(e, {
            session: m,
            user: o.user
        }), p = m.token;
    }
    return e.json({
        token: p
    });
}), er = E("/set-password", {
    method: "POST",
    body: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        newPassword: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string()
    }),
    metadata: {
        SERVER_ONLY: !0
    },
    use: [
        j
    ]
}, async (e)=>{
    let { newPassword: t } = e.body, r = e.context.session, n = e.context.password.config.minPasswordLength;
    if (t.length < n) throw e.context.logger.error("Password is too short"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.PASSWORD_TOO_SHORT
    });
    let o = e.context.password.config.maxPasswordLength;
    if (t.length > o) throw e.context.logger.error("Password is too long"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.PASSWORD_TOO_LONG
    });
    let d = (await e.context.internalAdapter.findAccounts(r.user.id)).find((s)=>s.providerId === "credential" && s.password), l = await e.context.password.hash(t);
    if (!d) return await e.context.internalAdapter.linkAccount({
        userId: r.user.id,
        providerId: "credential",
        accountId: r.user.id,
        password: l
    }), e.json({
        status: !0
    });
    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "user already has a password"
    });
}), tr = E("/delete-user", {
    method: "POST",
    use: [
        j
    ],
    body: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        callbackURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional(),
        password: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional(),
        token: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional()
    }),
    metadata: {
        openapi: {
            description: "Delete the user",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object"
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    if (!e.context.options.user?.deleteUser?.enabled) throw e.context.logger.error("Delete user is disabled. Enable it in the options", {
        session: e.context.session
    }), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("NOT_FOUND");
    let t = e.context.session;
    if (e.body.password) {
        let i = (await e.context.internalAdapter.findAccounts(t.user.id)).find((l)=>l.providerId === "credential" && l.password);
        if (!i || !i.password) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
            message: w.CREDENTIAL_ACCOUNT_NOT_FOUND
        });
        if (!await e.context.password.verify({
            hash: i.password,
            password: e.body.password
        })) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
            message: w.INVALID_PASSWORD
        });
    } else if (e.context.options.session?.freshAge) {
        let o = t.session.createdAt.getTime(), i = e.context.options.session.freshAge;
        if (Date.now() - o > i) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
            message: w.SESSION_EXPIRED
        });
    }
    if (e.body.token) return await He({
        ...e,
        query: {
            token: e.body.token
        }
    }), e.json({
        success: !0,
        message: "User deleted"
    });
    if (e.context.options.user.deleteUser?.sendDeleteAccountVerification) {
        let o = me(32, "0-9", "a-z");
        await e.context.internalAdapter.createVerificationValue({
            value: t.user.id,
            identifier: `delete-account-${o}`,
            expiresAt: new Date(Date.now() + 1e3 * 60 * 60 * 24)
        });
        let i = `${e.context.baseURL}/delete-user/callback?token=${o}&callbackURL=${e.body.callbackURL || "/"}`;
        return await e.context.options.user.deleteUser.sendDeleteAccountVerification({
            user: t.user,
            url: i,
            token: o
        }, e.request), e.json({
            success: !0,
            message: "Verification email sent"
        });
    }
    let r = e.context.options.user.deleteUser?.beforeDelete;
    r && await r(t.user, e.request), await e.context.internalAdapter.deleteUser(t.user.id), await e.context.internalAdapter.deleteSessions(t.user.id), await e.context.internalAdapter.deleteAccounts(t.user.id), M(e);
    let n = e.context.options.user.deleteUser?.afterDelete;
    return n && await n(t.user, e.request), e.json({
        success: !0,
        message: "User deleted"
    });
}), He = E("/delete-user/callback", {
    method: "GET",
    query: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        token: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
        callbackURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional()
    })
}, async (e)=>{
    if (!e.context.options.user?.deleteUser?.enabled) throw e.context.logger.error("Delete user is disabled. Enable it in the options"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("NOT_FOUND");
    let t = await oe(e);
    if (!t) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("NOT_FOUND", {
        message: w.FAILED_TO_GET_USER_INFO
    });
    let r = await e.context.internalAdapter.findVerificationValue(`delete-account-${e.query.token}`);
    if (!r || r.expiresAt < new Date) throw r && await e.context.internalAdapter.deleteVerificationValue(r.id), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("NOT_FOUND", {
        message: w.INVALID_TOKEN
    });
    if (r.value !== t.user.id) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("NOT_FOUND", {
        message: w.INVALID_TOKEN
    });
    let n = e.context.options.user.deleteUser?.beforeDelete;
    n && await n(t.user, e.request), await e.context.internalAdapter.deleteUser(t.user.id), await e.context.internalAdapter.deleteSessions(t.user.id), await e.context.internalAdapter.deleteAccounts(t.user.id), await e.context.internalAdapter.deleteVerificationValue(r.id), M(e);
    let o = e.context.options.user.deleteUser?.afterDelete;
    if (o && await o(t.user, e.request), e.query.callbackURL) throw e.redirect(e.query.callbackURL || "/");
    return e.json({
        success: !0,
        message: "User deleted"
    });
}), rr = E("/change-email", {
    method: "POST",
    query: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        currentURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional()
    }).optional(),
    body: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        newEmail: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The new email to set"
        }).email(),
        callbackURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The URL to redirect to after email verification"
        }).optional()
    }),
    use: [
        j
    ],
    metadata: {
        openapi: {
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    user: {
                                        type: "object"
                                    },
                                    status: {
                                        type: "boolean"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    if (!e.context.options.user?.changeEmail?.enabled) throw e.context.logger.error("Change email is disabled."), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "Change email is disabled"
    });
    if (e.body.newEmail === e.context.session.user.email) throw e.context.logger.error("Email is the same"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "Email is the same"
    });
    if (await e.context.internalAdapter.findUserByEmail(e.body.newEmail)) throw e.context.logger.error("Email already exists"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "Couldn't update your email"
    });
    if (e.context.session.user.emailVerified !== !0) {
        let o = await e.context.internalAdapter.updateUserByEmail(e.context.session.user.email, {
            email: e.body.newEmail
        });
        return e.json({
            status: !0
        });
    }
    if (!e.context.options.user.changeEmail.sendChangeEmailVerification) throw e.context.logger.error("Verification email isn't enabled."), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "Verification email isn't enabled"
    });
    let r = await W(e.context.secret, e.context.session.user.email, e.body.newEmail), n = `${e.context.baseURL}/verify-email?token=${r}&callbackURL=${e.body.callbackURL || e.query?.currentURL || "/"}`;
    return await e.context.options.user.changeEmail.sendChangeEmailVerification({
        user: e.context.session.user,
        newEmail: e.body.newEmail,
        url: n,
        token: r
    }, e.request), e.json({
        status: !0
    });
});
var Ln = (e = "Unknown")=>`<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authentication Error</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --text-color: #212529;
            --accent-color: #000000;
            --error-color: #dc3545;
            --border-color: #e9ecef;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            line-height: 1.5;
        }
        .error-container {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            padding: 2.5rem;
            text-align: center;
            max-width: 90%;
            width: 400px;
        }
        h1 {
            color: var(--error-color);
            font-size: 1.75rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }
        p {
            margin-bottom: 1.5rem;
            color: #495057;
        }
        .btn {
            background-color: var(--accent-color);
            color: #ffffff;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            transition: all 0.3s ease;
            display: inline-block;
            font-weight: 500;
            border: 2px solid var(--accent-color);
        }
        .btn:hover {
            background-color: #131721;
        }
        .error-code {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        .icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="error-container">
        <div class="icon">\u26A0\uFE0F</div>
        <h1>Better Auth Error</h1>
        <p>We encountered an issue while processing your request. Please try again or contact the application owner if the problem persists.</p>
        <a href="/" id="returnLink" class="btn">Return to Application</a>
        <div class="error-code">Error Code: <span id="errorCode">${e}</span></div>
    </div>
</body>
</html>`, nr = E("/error", {
    method: "GET",
    metadata: {
        ...se,
        openapi: {
            description: "Displays an error page",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "text/html": {
                            schema: {
                                type: "string"
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    let t = new URL(e.request?.url || "").searchParams.get("error") || "Unknown";
    return new Response(Ln(t), {
        headers: {
            "Content-Type": "text/html"
        }
    });
});
var or = E("/ok", {
    method: "GET",
    metadata: {
        ...se,
        openapi: {
            description: "Check if the API is working",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    ok: {
                                        type: "boolean"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>e.json({
        ok: !0
    }));
;
;
var ir = ()=>E("/sign-up/email", {
        method: "POST",
        query: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
            currentURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional()
        }).optional(),
        body: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].any()),
        metadata: {
            openapi: {
                description: "Sign up a user using email and password",
                requestBody: {
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    name: {
                                        type: "string",
                                        description: "The name of the user"
                                    },
                                    email: {
                                        type: "string",
                                        description: "The email of the user"
                                    },
                                    password: {
                                        type: "string",
                                        description: "The password of the user"
                                    },
                                    callbackURL: {
                                        type: "string",
                                        description: "The URL to use for email verification callback"
                                    }
                                },
                                required: [
                                    "name",
                                    "email",
                                    "password"
                                ]
                            }
                        }
                    }
                },
                responses: {
                    200: {
                        description: "Success",
                        content: {
                            "application/json": {
                                schema: {
                                    type: "object",
                                    properties: {
                                        id: {
                                            type: "string",
                                            description: "The id of the user"
                                        },
                                        email: {
                                            type: "string",
                                            description: "The email of the user"
                                        },
                                        name: {
                                            type: "string",
                                            description: "The name of the user"
                                        },
                                        image: {
                                            type: "string",
                                            description: "The image of the user"
                                        },
                                        emailVerified: {
                                            type: "boolean",
                                            description: "If the email is verified"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }, async (e)=>{
        if (!e.context.options.emailAndPassword?.enabled) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
            message: "Email and password sign up is not enabled"
        });
        let t = e.body, { name: r, email: n, password: o, image: i, callbackURL: d, ...l } = t;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().email().safeParse(n).success) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
            message: w.INVALID_EMAIL
        });
        let a = e.context.password.config.minPasswordLength;
        if (o.length < a) throw e.context.logger.error("Password is too short"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
            message: w.PASSWORD_TOO_SHORT
        });
        let c = e.context.password.config.maxPasswordLength;
        if (o.length > c) throw e.context.logger.error("Password is too long"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
            message: w.PASSWORD_TOO_LONG
        });
        if ((await e.context.internalAdapter.findUserByEmail(n))?.user) throw e.context.logger.info(`Sign-up attempt for existing email: ${n}`), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNPROCESSABLE_ENTITY", {
            message: w.USER_ALREADY_EXISTS
        });
        let m = _e(e.context.options, l), u;
        try {
            if (u = await e.context.internalAdapter.createUser({
                email: n.toLowerCase(),
                name: r,
                image: i,
                ...m,
                emailVerified: !1
            }), !u) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
                message: w.FAILED_TO_CREATE_USER
            });
        } catch (b) {
            throw Te && e.context.logger.error("Failed to create user", b), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNPROCESSABLE_ENTITY", {
                message: w.FAILED_TO_CREATE_USER,
                details: b
            });
        }
        if (!u) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("UNPROCESSABLE_ENTITY", {
            message: w.FAILED_TO_CREATE_USER
        });
        let f = await e.context.password.hash(o);
        if (await e.context.internalAdapter.linkAccount({
            userId: u.id,
            providerId: "credential",
            accountId: u.id,
            password: f
        }), e.context.options.emailVerification?.sendOnSignUp || e.context.options.emailAndPassword.requireEmailVerification) {
            let b = await W(e.context.secret, u.email), A = `${e.context.baseURL}/verify-email?token=${b}&callbackURL=${t.callbackURL || e.query?.currentURL || "/"}`;
            await e.context.options.emailVerification?.sendVerificationEmail?.({
                user: u,
                url: A,
                token: b
            }, e.request);
        }
        if (!e.context.options.emailAndPassword.autoSignIn || e.context.options.emailAndPassword.requireEmailVerification) return e.json({
            token: null
        });
        let g = await e.context.internalAdapter.createSession(u.id, e.request);
        if (!g) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
            message: w.FAILED_TO_CREATE_SESSION
        });
        return await D(e, {
            session: g,
            user: u
        }), e.json({
            token: g.token
        });
    });
;
;
var ar = E("/list-accounts", {
    method: "GET",
    use: [
        j
    ],
    metadata: {
        openapi: {
            description: "List all accounts linked to the user",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "array",
                                items: {
                                    type: "object",
                                    properties: {
                                        id: {
                                            type: "string"
                                        },
                                        provider: {
                                            type: "string"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    let t = e.context.session, r = await e.context.internalAdapter.findAccounts(t.user.id);
    return e.json(r.map((n)=>({
            id: n.id,
            provider: n.providerId
        })));
}), dr = E("/link-social", {
    method: "POST",
    requireHeaders: !0,
    query: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        currentURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional()
    }).optional(),
    body: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        callbackURL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string({
            description: "The URL to redirect to after the user has signed in"
        }).optional(),
        provider: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].enum(Ve, {
            description: "The OAuth2 provider to use"
        })
    }),
    use: [
        j
    ],
    metadata: {
        openapi: {
            description: "Link a social account to the user",
            responses: {
                200: {
                    description: "Success",
                    content: {
                        "application/json": {
                            schema: {
                                type: "object",
                                properties: {
                                    url: {
                                        type: "string"
                                    },
                                    redirect: {
                                        type: "boolean"
                                    }
                                },
                                required: [
                                    "url",
                                    "redirect"
                                ]
                            }
                        }
                    }
                }
            }
        }
    }
}, async (e)=>{
    let t = e.context.session;
    if ((await e.context.internalAdapter.findAccounts(t.user.id)).find((l)=>l.providerId === e.body.provider)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: w.SOCIAL_ACCOUNT_ALREADY_LINKED
    });
    let o = e.context.socialProviders.find((l)=>l.id === e.body.provider);
    if (!o) throw e.context.logger.error("Provider not found. Make sure to add the provider in your auth config", {
        provider: e.body.provider
    }), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("NOT_FOUND", {
        message: w.PROVIDER_NOT_FOUND
    });
    let i = await ve(e, {
        userId: t.user.id,
        email: t.user.email
    }), d = await o.createAuthorizationURL({
        state: i.state,
        codeVerifier: i.codeVerifier,
        redirectURI: `${e.context.baseURL}/callback/${o.id}`
    });
    return e.json({
        url: d.toString(),
        redirect: !0
    });
});
function Ie(e, t) {
    if (t.advanced?.ipAddress?.disableIpTracking) return null;
    let r = "127.0.0.1";
    if (et) return r;
    let o = t.advanced?.ipAddress?.ipAddressHeaders || [
        "x-client-ip",
        "x-forwarded-for",
        "cf-connecting-ip",
        "fastly-client-ip",
        "x-real-ip",
        "x-cluster-client-ip",
        "x-forwarded",
        "forwarded-for",
        "forwarded"
    ], i = e instanceof Request ? e.headers : e;
    for (let d of o){
        let l = i.get(d);
        if (typeof l == "string") {
            let s = l.split(",")[0].trim();
            if (s) return s;
        }
    }
    return null;
}
function Dn(e, t, r) {
    let n = Date.now(), o = t * 1e3;
    return n - r.lastRequest < o && r.count >= e;
}
function Cn(e) {
    return new Response(JSON.stringify({
        message: "Too many requests. Please try again later."
    }), {
        status: 429,
        statusText: "Too Many Requests",
        headers: {
            "X-Retry-After": e.toString()
        }
    });
}
function Nn(e, t) {
    let r = Date.now(), n = t * 1e3;
    return Math.ceil((e + n - r) / 1e3);
}
function Bn(e, t) {
    let r = "rateLimit", n = e.adapter;
    return {
        get: async (o)=>(await n.findMany({
                model: r,
                where: [
                    {
                        field: "key",
                        value: o
                    }
                ]
            }))[0],
        set: async (o, i, d)=>{
            try {
                d ? await n.updateMany({
                    model: t ?? "rateLimit",
                    where: [
                        {
                            field: "key",
                            value: o
                        }
                    ],
                    update: {
                        count: i.count,
                        lastRequest: i.lastRequest
                    }
                }) : await n.create({
                    model: t ?? "rateLimit",
                    data: {
                        key: o,
                        count: i.count,
                        lastRequest: i.lastRequest
                    }
                });
            } catch (l) {
                e.logger.error("Error setting rate limit", l);
            }
        }
    };
}
var cr = new Map;
function jn(e) {
    return e.options.rateLimit?.customStorage ? e.options.rateLimit.customStorage : e.rateLimit.storage === "secondary-storage" ? {
        get: async (r)=>{
            let n = await e.options.secondaryStorage?.get(r);
            return n ? JSON.parse(n) : void 0;
        },
        set: async (r, n)=>{
            await e.options.secondaryStorage?.set?.(r, JSON.stringify(n));
        }
    } : e.rateLimit.storage === "memory" ? {
        async get (r) {
            return cr.get(r);
        },
        async set (r, n, o) {
            cr.set(r, n);
        }
    } : Bn(e, e.rateLimit.modelName);
}
async function lr(e, t) {
    if (!t.rateLimit.enabled) return;
    let r = t.baseURL, n = e.url.replace(r, "").split("?")[0], o = t.rateLimit.window, i = t.rateLimit.max, d = Ie(e, t.options) + n, s = Fn().find((m)=>m.pathMatcher(n));
    s && (o = s.window, i = s.max);
    for (let m of t.options.plugins || [])if (m.rateLimit) {
        let u = m.rateLimit.find((f)=>f.pathMatcher(n));
        if (u) {
            o = u.window, i = u.max;
            break;
        }
    }
    if (t.rateLimit.customRules) {
        let m = Object.keys(t.rateLimit.customRules).find((u)=>u.includes("*") ? Ae(u)(n) : u === n);
        if (m) {
            let u = t.rateLimit.customRules[m], f = typeof u == "function" ? await u(e) : u;
            f && (o = f.window, i = f.max);
        }
    }
    let a = jn(t), c = await a.get(d), p = Date.now();
    if (!c) await a.set(d, {
        key: d,
        count: 1,
        lastRequest: p
    });
    else {
        let m = p - c.lastRequest;
        if (Dn(i, o, c)) {
            let u = Nn(c.lastRequest, o);
            return Cn(u);
        } else m > o * 1e3 ? await a.set(d, {
            ...c,
            count: 1,
            lastRequest: p
        }, !0) : await a.set(d, {
            ...c,
            count: c.count + 1,
            lastRequest: p
        }, !0);
    }
}
function Fn() {
    return [
        {
            pathMatcher (t) {
                return t.startsWith("/sign-in") || t.startsWith("/sign-up") || t.startsWith("/change-password") || t.startsWith("/change-email");
            },
            window: 10,
            max: 3
        }
    ];
}
;
;
function We(e, t) {
    let r = t.plugins?.reduce((l, s)=>({
            ...l,
            ...s.endpoints
        }), {}), n = t.plugins?.map((l)=>l.middlewares?.map((s)=>{
            let a = async (c)=>s.middleware({
                    ...c,
                    context: {
                        ...e,
                        ...c.context
                    }
                });
            return a.path = s.path, a.options = s.middleware.options, a.headers = s.middleware.headers, {
                path: s.path,
                middleware: a
            };
        })).filter((l)=>l !== void 0).flat() || [], i = {
        ...{
            signInSocial: Mt,
            callbackOAuth: Ht,
            getSession: $e(),
            signOut: Wt,
            signUpEmail: ir(),
            signInEmail: zt,
            forgetPassword: Kt,
            resetPassword: Jt,
            verifyEmail: Vt,
            sendVerificationEmail: qt,
            changeEmail: rr,
            changePassword: Xt,
            setPassword: er,
            updateUser: Yt(),
            deleteUser: tr,
            forgetPasswordCallback: Qt,
            listSessions: Ct(),
            revokeSession: Nt,
            revokeSessions: Bt,
            revokeOtherSessions: jt,
            linkSocialAccount: dr,
            listUserAccounts: ar,
            deleteUserCallback: He
        },
        ...r,
        ok: or,
        error: nr
    }, d = {};
    for (let [l, s] of Object.entries(i))d[l] = async (a = {})=>{
        s.headers = new Headers;
        let c = {
            setHeader (h, y) {
                s.headers.set(h, y);
            },
            setCookie (h, y, x) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setCookie"])(s.headers, h, y, x);
            },
            getCookie (h, y) {
                let k = a.headers?.get("cookie");
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCookie"])(k || "", h, y);
            },
            getSignedCookie (h, y, x) {
                let k = a.headers;
                return k ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSignedCookie"])(k, y, h, x) : null;
            },
            async setSignedCookie (h, y, x, k) {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setSignedCookie"])(s.headers, h, y, x, k);
            },
            redirect (h) {
                return s.headers.set("Location", h), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("FOUND");
            },
            responseHeader: s.headers
        }, p = await e, m = null, u = {
            ...c,
            ...a,
            path: s.path,
            context: {
                ...p,
                ...a.context,
                session: null,
                setNewSession: function(h) {
                    this.newSession = h, m = h;
                }
            }
        }, f = t.plugins || [], g = f.map((h)=>{
            if (h.hooks?.before) return h.hooks.before;
        }).filter((h)=>h !== void 0).flat(), b = f.map((h)=>{
            if (h.hooks?.after) return h.hooks.after;
        }).filter((h)=>h !== void 0).flat();
        t.hooks?.before && g.push({
            matcher: ()=>!0,
            handler: t.hooks.before
        }), t.hooks?.after && b.push({
            matcher: ()=>!0,
            handler: t.hooks.after
        });
        for (let h of g){
            if (!h.matcher(u)) continue;
            let y = await h.handler(u);
            if (y && "context" in y) {
                u = {
                    ...u,
                    ...y.context
                };
                continue;
            }
            if (y) return y;
        }
        let A;
        try {
            A = await s(u), m && (u.context.newSession = m);
        } catch (h) {
            if (m && (u.context.newSession = m), h instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]) {
                if (!b?.length) throw h.headers = s.headers, h;
                u.context.returned = h, u.context.returned.headers = s.headers;
                for (let y of b || [])if (y.matcher(u)) try {
                    let k = await y.handler(u);
                    k && "response" in k && (u.context.returned = k.response);
                } catch (k) {
                    if (k instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]) {
                        u.context.returned = k;
                        continue;
                    }
                    throw k;
                }
                if (u.context.returned instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]) throw u.context.returned.headers = s.headers, u.context.returned;
                return u.context.returned;
            }
            throw h;
        }
        u.context.returned = A, u.responseHeader = s.headers;
        for (let h of b)if (h.matcher(u)) try {
            let x = await h.handler(u);
            if (x) if ("responseHeader" in x) {
                let k = x.responseHeader;
                u.responseHeader = k;
            } else u.context.returned = x;
        } catch (x) {
            if (x instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]) {
                u.context.returned = x;
                continue;
            }
            throw x;
        }
        let R = u.context.returned;
        if (R instanceof Response && s.headers.forEach((h, y)=>{
            y === "set-cookie" ? R.headers.append(y, h) : R.headers.set(y, h);
        }), R instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]) throw R.headers = s.headers, R;
        return R;
    }, d[l].path = s.path, d[l].method = s.method, d[l].options = s.options, d[l].headers = s.headers;
    return {
        api: d,
        middlewares: n
    };
}
var ur = (e, t)=>{
    let { api: r, middlewares: n } = We(e, t), o = new URL(e.baseURL).pathname;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createRouter"])(r, {
        extraContext: e,
        basePath: o,
        routerMiddleware: [
            {
                path: "/**",
                middleware: ot
            },
            ...n
        ],
        async onRequest (i) {
            for (let d of e.options.plugins || [])if (d.onRequest) {
                let l = await d.onRequest(i, e);
                if (l && "response" in l) return l.response;
            }
            return lr(i, e);
        },
        async onResponse (i) {
            for (let d of e.options.plugins || [])if (d.onResponse) {
                let l = await d.onResponse(i, e);
                if (l) return l.response;
            }
            return i;
        },
        onError (i) {
            if (i instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"] && i.status === "FOUND") return;
            if (t.onAPIError?.throw) throw i;
            if (t.onAPIError?.onError) {
                t.onAPIError.onError(i, e);
                return;
            }
            let d = t.logger?.level, l = d === "error" || d === "warn" || d === "debug" ? C : void 0;
            if (t.logger?.disabled !== !0) {
                if (i && typeof i == "object" && "message" in i && typeof i.message == "string" && (i.message.includes("no column") || i.message.includes("column") || i.message.includes("relation") || i.message.includes("table") || i.message.includes("does not exist"))) {
                    e.logger?.error(i.message);
                    return;
                }
                i instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"] ? (i.status === "INTERNAL_SERVER_ERROR" && e.logger.error(i.status, i), l?.error(i.message)) : e.logger?.error(i && typeof i == "object" && "name" in i ? i.name : "", i);
            }
        }
    });
};
;
function pr(e, t) {
    let r = t.hooks;
    async function n(d, l, s) {
        let a = d;
        for (let m of r || []){
            let u = m[l]?.create?.before;
            if (u) {
                let f = await u(d);
                if (f === !1) return null;
                typeof f == "object" && "data" in f && (a = f.data);
            }
        }
        let c = s ? await s.fn(a) : null, p = !s || s.executeMainFn ? await e.create({
            model: l,
            data: a
        }) : c;
        for (let m of r || []){
            let u = m[l]?.create?.after;
            u && await u(p);
        }
        return p;
    }
    async function o(d, l, s, a) {
        let c = d;
        for (let u of r || []){
            let f = u[s]?.update?.before;
            if (f) {
                let g = await f(d);
                if (g === !1) return null;
                c = typeof g == "object" ? g.data : g;
            }
        }
        let p = a ? await a.fn(c) : null, m = !a || a.executeMainFn ? await e.update({
            model: s,
            update: c,
            where: l
        }) : p;
        for (let u of r || []){
            let f = u[s]?.update?.after;
            f && await f(m);
        }
        return m;
    }
    async function i(d, l, s, a) {
        let c = d;
        for (let u of r || []){
            let f = u[s]?.update?.before;
            if (f) {
                let g = await f(d);
                if (g === !1) return null;
                c = typeof g == "object" ? g.data : g;
            }
        }
        let p = a ? await a.fn(c) : null, m = !a || a.executeMainFn ? await e.updateMany({
            model: s,
            update: c,
            where: l
        }) : p;
        for (let u of r || []){
            let f = u[s]?.update?.after;
            f && await f(m);
        }
        return m;
    }
    return {
        createWithHooks: n,
        updateWithHooks: o,
        updateManyWithHooks: i
    };
}
var Ge = (e, t)=>{
    let r = t.options, n = r.secondaryStorage, o = r.session?.expiresIn || 60 * 60 * 24 * 7, { createWithHooks: i, updateWithHooks: d, updateManyWithHooks: l } = pr(e, t);
    return {
        createOAuthUser: async (s, a)=>{
            let c = await i({
                createdAt: new Date,
                updatedAt: new Date,
                ...s
            }, "user"), p = await i({
                ...a,
                userId: c.id || s.id,
                createdAt: new Date,
                updatedAt: new Date
            }, "account");
            return {
                user: c,
                account: p
            };
        },
        createUser: async (s)=>await i({
                createdAt: new Date,
                updatedAt: new Date,
                emailVerified: !1,
                ...s,
                email: s.email.toLowerCase()
            }, "user"),
        createAccount: async (s)=>await i({
                createdAt: new Date,
                updatedAt: new Date,
                ...s
            }, "account"),
        listSessions: async (s)=>{
            if (n) {
                let c = await n.get(`active-sessions-${s}`);
                if (!c) return [];
                let p = ae(c) || [], m = Date.now(), u = p.filter((g)=>g.expiresAt > m), f = [];
                for (let g of u){
                    let b = await n.get(g.token);
                    if (b) {
                        let A = JSON.parse(b), R = Se(t.options, {
                            ...A.session,
                            expiresAt: new Date(A.session.expiresAt)
                        });
                        f.push(R);
                    }
                }
                return f;
            }
            return await e.findMany({
                model: "session",
                where: [
                    {
                        field: "userId",
                        value: s
                    }
                ]
            });
        },
        listUsers: async (s, a, c, p)=>await e.findMany({
                model: "user",
                limit: s,
                offset: a,
                sortBy: c,
                where: p
            }),
        deleteUser: async (s)=>{
            await e.deleteMany({
                model: "session",
                where: [
                    {
                        field: "userId",
                        value: s
                    }
                ]
            }), await e.deleteMany({
                model: "account",
                where: [
                    {
                        field: "userId",
                        value: s
                    }
                ]
            }), await e.delete({
                model: "user",
                where: [
                    {
                        field: "id",
                        value: s
                    }
                ]
            });
        },
        createSession: async (s, a, c, p)=>{
            let m = a instanceof Request ? a.headers : a, { id: u, ...f } = p || {}, g = {
                ipAddress: a && Ie(a, t.options) || "",
                userAgent: m?.get("user-agent") || "",
                ...f,
                expiresAt: c ? V(60 * 60 * 24, "sec") : V(o, "sec"),
                userId: s,
                token: H(32),
                createdAt: new Date,
                updatedAt: new Date
            };
            return await i(g, "session", n ? {
                fn: async (A)=>{
                    let R = await n.get(`active-sessions-${s}`), h = [], y = Date.now();
                    return R && (h = ae(R) || [], h = h.filter((x)=>x.expiresAt > y)), h.push({
                        token: g.token,
                        expiresAt: y + o * 1e3
                    }), await n.set(`active-sessions-${s}`, JSON.stringify(h), o), A;
                },
                executeMainFn: r.session?.storeSessionInDatabase
            } : void 0);
        },
        findSession: async (s)=>{
            if (n) {
                let u = await n.get(s);
                if (u) {
                    let f = JSON.parse(u), g = Se(t.options, {
                        ...f.session,
                        expiresAt: new Date(f.session.expiresAt),
                        createdAt: new Date(f.session.createdAt),
                        updatedAt: new Date(f.session.updatedAt)
                    }), b = ze(t.options, {
                        ...f.user,
                        createdAt: new Date(f.user.createdAt),
                        updatedAt: new Date(f.user.updatedAt)
                    });
                    return {
                        session: g,
                        user: b
                    };
                }
            }
            let a = await e.findOne({
                model: "session",
                where: [
                    {
                        value: s,
                        field: "token"
                    }
                ]
            });
            if (!a) return null;
            let c = await e.findOne({
                model: "user",
                where: [
                    {
                        value: a.userId,
                        field: "id"
                    }
                ]
            });
            if (!c) return null;
            let p = Se(t.options, a), m = ze(t.options, c);
            return n && await n?.set(s, JSON.stringify({
                session: p,
                user: m
            }), p.expiresAt ? Math.floor(((p.expiresAt instanceof Date ? p.expiresAt.getTime() : new Date(p.expiresAt).getTime()) - Date.now()) / 1e3) : o), {
                session: p,
                user: m
            };
        },
        findSessions: async (s)=>{
            if (n) {
                let m = [];
                for (let u of s){
                    let f = await n.get(u);
                    if (f) {
                        let g = JSON.parse(f), b = {
                            session: {
                                ...g.session,
                                expiresAt: new Date(g.session.expiresAt)
                            },
                            user: {
                                ...g.user,
                                createdAt: new Date(g.user.createdAt),
                                updatedAt: new Date(g.user.updatedAt)
                            }
                        };
                        m.push(b);
                    }
                }
                return m;
            }
            let a = await e.findMany({
                model: "session",
                where: [
                    {
                        field: "token",
                        value: s,
                        operator: "in"
                    }
                ]
            }), c = a.map((m)=>m.userId);
            if (!c.length) return [];
            let p = await e.findMany({
                model: "user",
                where: [
                    {
                        field: "id",
                        value: c,
                        operator: "in"
                    }
                ]
            });
            return a.map((m)=>{
                let u = p.find((f)=>f.id === m.userId);
                return u ? {
                    session: m,
                    user: u
                } : null;
            });
        },
        updateSession: async (s, a)=>await d(a, [
                {
                    field: "token",
                    value: s
                }
            ], "session", n ? {
                async fn (p) {
                    let m = await n.get(s), u = null;
                    return m ? (u = {
                        ...JSON.parse(m).session,
                        ...p
                    }, u) : null;
                },
                executeMainFn: r.session?.storeSessionInDatabase
            } : void 0),
        deleteSession: async (s)=>{
            if (n) {
                await n.delete(s), r.session?.storeSessionInDatabase && await e.delete({
                    model: "session",
                    where: [
                        {
                            field: "token",
                            value: s
                        }
                    ]
                });
                return;
            }
            await e.delete({
                model: "session",
                where: [
                    {
                        field: "token",
                        value: s
                    }
                ]
            });
        },
        deleteAccounts: async (s)=>{
            await e.deleteMany({
                model: "account",
                where: [
                    {
                        field: "userId",
                        value: s
                    }
                ]
            });
        },
        deleteSessions: async (s)=>{
            if (n) {
                if (typeof s == "string") {
                    let a = await n.get(`active-sessions-${s}`), c = a ? ae(a) : [];
                    if (!c) return;
                    for (let p of c)await n.delete(p.token);
                } else for (let a of s)await n.get(a) && await n.delete(a);
                r.session?.storeSessionInDatabase && await e.deleteMany({
                    model: "session",
                    where: [
                        {
                            field: Array.isArray(s) ? "token" : "userId",
                            value: s,
                            operator: Array.isArray(s) ? "in" : void 0
                        }
                    ]
                });
                return;
            }
            await e.deleteMany({
                model: "session",
                where: [
                    {
                        field: Array.isArray(s) ? "token" : "userId",
                        value: s,
                        operator: Array.isArray(s) ? "in" : void 0
                    }
                ]
            });
        },
        findOAuthUser: async (s, a, c)=>{
            let p = null;
            if (p = await e.findOne({
                model: "user",
                where: [
                    {
                        value: s.toLowerCase(),
                        field: "email"
                    }
                ]
            }), !p) {
                let u = await e.findOne({
                    model: "account",
                    where: [
                        {
                            value: a,
                            field: "accountId"
                        },
                        {
                            value: c,
                            field: "providerId"
                        }
                    ]
                });
                return u ? (p = await e.findOne({
                    model: "user",
                    where: [
                        {
                            value: u.userId,
                            field: "id"
                        }
                    ]
                }), {
                    user: p,
                    accounts: [
                        u
                    ]
                }) : null;
            }
            let m = await e.findMany({
                model: "account",
                where: [
                    {
                        value: p.id,
                        field: "userId"
                    }
                ]
            });
            return {
                user: p,
                accounts: m || []
            };
        },
        findUserByEmail: async (s, a)=>{
            let c = await e.findOne({
                model: "user",
                where: [
                    {
                        value: s.toLowerCase(),
                        field: "email"
                    }
                ]
            });
            if (!c) return null;
            if (a?.includeAccounts) {
                let p = await e.findMany({
                    model: "account",
                    where: [
                        {
                            value: c.id,
                            field: "userId"
                        }
                    ]
                });
                return {
                    user: c,
                    accounts: p
                };
            }
            return {
                user: c,
                accounts: []
            };
        },
        findUserById: async (s)=>await e.findOne({
                model: "user",
                where: [
                    {
                        field: "id",
                        value: s
                    }
                ]
            }),
        linkAccount: async (s)=>await i({
                ...s,
                createdAt: new Date,
                updatedAt: new Date
            }, "account"),
        updateUser: async (s, a)=>await d(a, [
                {
                    field: "id",
                    value: s
                }
            ], "user"),
        updateUserByEmail: async (s, a)=>await d(a, [
                {
                    field: "email",
                    value: s
                }
            ], "user"),
        updatePassword: async (s, a)=>{
            await l({
                password: a
            }, [
                {
                    field: "userId",
                    value: s
                },
                {
                    field: "providerId",
                    value: "credential"
                }
            ], "account");
        },
        findAccounts: async (s)=>await e.findMany({
                model: "account",
                where: [
                    {
                        field: "userId",
                        value: s
                    }
                ]
            }),
        findAccount: async (s)=>await e.findOne({
                model: "account",
                where: [
                    {
                        field: "accountId",
                        value: s
                    }
                ]
            }),
        findAccountByUserId: async (s)=>await e.findMany({
                model: "account",
                where: [
                    {
                        field: "userId",
                        value: s
                    }
                ]
            }),
        updateAccount: async (s, a)=>await d(a, [
                {
                    field: "id",
                    value: s
                }
            ], "account"),
        createVerificationValue: async (s)=>await i({
                createdAt: new Date,
                updatedAt: new Date,
                ...s
            }, "verification"),
        findVerificationValue: async (s)=>(await e.findMany({
                model: "verification",
                where: [
                    {
                        field: "identifier",
                        value: s
                    }
                ],
                sortBy: {
                    field: "createdAt",
                    direction: "desc"
                },
                limit: 1
            }))[0],
        deleteVerificationValue: async (s)=>{
            await e.delete({
                model: "verification",
                where: [
                    {
                        field: "id",
                        value: s
                    }
                ]
            });
        },
        deleteVerificationByIdentifier: async (s)=>{
            await e.delete({
                model: "verification",
                where: [
                    {
                        field: "identifier",
                        value: s
                    }
                ]
            });
        },
        updateVerificationValue: async (s, a)=>await d(a, [
                {
                    field: "id",
                    value: s
                }
            ], "verification")
    };
};
var Y = (e)=>{
    let t = e.plugins?.reduce((s, a)=>{
        let c = a.schema;
        if (!c) return s;
        for (let [p, m] of Object.entries(c))s[p] = {
            fields: {
                ...s[p]?.fields,
                ...m.fields
            },
            modelName: m.modelName || p
        };
        return s;
    }, {}), r = e.rateLimit?.storage === "database", n = {
        rateLimit: {
            modelName: e.rateLimit?.modelName || "rateLimit",
            fields: {
                key: {
                    type: "string",
                    fieldName: e.rateLimit?.fields?.key || "key"
                },
                count: {
                    type: "number",
                    fieldName: e.rateLimit?.fields?.count || "count"
                },
                lastRequest: {
                    type: "number",
                    fieldName: e.rateLimit?.fields?.lastRequest || "lastRequest"
                }
            }
        }
    }, { user: o, session: i, account: d, ...l } = t || {};
    return {
        user: {
            modelName: e.user?.modelName || "user",
            fields: {
                name: {
                    type: "string",
                    required: !0,
                    fieldName: e.user?.fields?.name || "name"
                },
                email: {
                    type: "string",
                    unique: !0,
                    required: !0,
                    fieldName: e.user?.fields?.email || "email"
                },
                emailVerified: {
                    type: "boolean",
                    defaultValue: ()=>!1,
                    required: !0,
                    fieldName: e.user?.fields?.emailVerified || "emailVerified"
                },
                image: {
                    type: "string",
                    required: !1,
                    fieldName: e.user?.fields?.image || "image"
                },
                createdAt: {
                    type: "date",
                    defaultValue: ()=>new Date,
                    required: !0,
                    fieldName: e.user?.fields?.createdAt || "createdAt"
                },
                updatedAt: {
                    type: "date",
                    defaultValue: ()=>new Date,
                    required: !0,
                    fieldName: e.user?.fields?.updatedAt || "updatedAt"
                },
                ...o?.fields,
                ...e.user?.additionalFields
            },
            order: 1
        },
        session: {
            modelName: e.session?.modelName || "session",
            fields: {
                expiresAt: {
                    type: "date",
                    required: !0,
                    fieldName: e.session?.fields?.expiresAt || "expiresAt"
                },
                token: {
                    type: "string",
                    required: !0,
                    fieldName: e.session?.fields?.token || "token",
                    unique: !0
                },
                createdAt: {
                    type: "date",
                    required: !0,
                    fieldName: e.session?.fields?.createdAt || "createdAt"
                },
                updatedAt: {
                    type: "date",
                    required: !0,
                    fieldName: e.session?.fields?.updatedAt || "updatedAt"
                },
                ipAddress: {
                    type: "string",
                    required: !1,
                    fieldName: e.session?.fields?.ipAddress || "ipAddress"
                },
                userAgent: {
                    type: "string",
                    required: !1,
                    fieldName: e.session?.fields?.userAgent || "userAgent"
                },
                userId: {
                    type: "string",
                    fieldName: e.session?.fields?.userId || "userId",
                    references: {
                        model: e.user?.modelName || "user",
                        field: "id",
                        onDelete: "cascade"
                    },
                    required: !0
                },
                ...i?.fields,
                ...e.session?.additionalFields
            },
            order: 2
        },
        account: {
            modelName: e.account?.modelName || "account",
            fields: {
                accountId: {
                    type: "string",
                    required: !0,
                    fieldName: e.account?.fields?.accountId || "accountId"
                },
                providerId: {
                    type: "string",
                    required: !0,
                    fieldName: e.account?.fields?.providerId || "providerId"
                },
                userId: {
                    type: "string",
                    references: {
                        model: e.user?.modelName || "user",
                        field: "id",
                        onDelete: "cascade"
                    },
                    required: !0,
                    fieldName: e.account?.fields?.userId || "userId"
                },
                accessToken: {
                    type: "string",
                    required: !1,
                    fieldName: e.account?.fields?.accessToken || "accessToken"
                },
                refreshToken: {
                    type: "string",
                    required: !1,
                    fieldName: e.account?.fields?.refreshToken || "refreshToken"
                },
                idToken: {
                    type: "string",
                    required: !1,
                    fieldName: e.account?.fields?.idToken || "idToken"
                },
                accessTokenExpiresAt: {
                    type: "date",
                    required: !1,
                    fieldName: e.account?.fields?.accessTokenExpiresAt || "accessTokenExpiresAt"
                },
                refreshTokenExpiresAt: {
                    type: "date",
                    required: !1,
                    fieldName: e.account?.fields?.accessTokenExpiresAt || "refreshTokenExpiresAt"
                },
                scope: {
                    type: "string",
                    required: !1,
                    fieldName: e.account?.fields?.scope || "scope"
                },
                password: {
                    type: "string",
                    required: !1,
                    fieldName: e.account?.fields?.password || "password"
                },
                createdAt: {
                    type: "date",
                    required: !0,
                    fieldName: e.account?.fields?.createdAt || "createdAt"
                },
                updatedAt: {
                    type: "date",
                    required: !0,
                    fieldName: e.account?.fields?.updatedAt || "updatedAt"
                },
                ...d?.fields
            },
            order: 3
        },
        verification: {
            modelName: e.verification?.modelName || "verification",
            fields: {
                identifier: {
                    type: "string",
                    required: !0,
                    fieldName: e.verification?.fields?.identifier || "identifier"
                },
                value: {
                    type: "string",
                    required: !0,
                    fieldName: e.verification?.fields?.value || "value"
                },
                expiresAt: {
                    type: "date",
                    required: !0,
                    fieldName: e.verification?.fields?.expiresAt || "expiresAt"
                },
                createdAt: {
                    type: "date",
                    required: !1,
                    defaultValue: ()=>new Date,
                    fieldName: e.verification?.fields?.createdAt || "createdAt"
                },
                updatedAt: {
                    type: "date",
                    required: !1,
                    defaultValue: ()=>new Date,
                    fieldName: e.verification?.fields?.updatedAt || "updatedAt"
                }
            },
            order: 4
        },
        ...l,
        ...r ? n : {}
    };
};
;
;
;
function yr(e) {
    if (!e) return null;
    if ("dialect" in e) return yr(e.dialect);
    if ("createDriver" in e) {
        if (e instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$dialect$2f$sqlite$2f$sqlite$2d$dialect$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SqliteDialect"]) return "sqlite";
        if (e instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$dialect$2f$mysql$2f$mysql$2d$dialect$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MysqlDialect"]) return "mysql";
        if (e instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$dialect$2f$postgres$2f$postgres$2d$dialect$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PostgresDialect"]) return "postgres";
        if (e instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$dialect$2f$mssql$2f$mssql$2d$dialect$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MssqlDialect"]) return "mssql";
    }
    return "aggregate" in e ? "sqlite" : "getConnection" in e ? "mysql" : "connect" in e ? "postgres" : null;
}
var Ke = async (e)=>{
    let t = e.database;
    if (!t) return {
        kysely: null,
        databaseType: null
    };
    if ("db" in t) return {
        kysely: t.db,
        databaseType: t.type
    };
    if ("dialect" in t) return {
        kysely: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$kysely$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kysely"]({
            dialect: t.dialect
        }),
        databaseType: t.type
    };
    let r, n = yr(t);
    return "createDriver" in t && (r = t), "aggregate" in t && (r = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$dialect$2f$sqlite$2f$sqlite$2d$dialect$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SqliteDialect"]({
        database: t
    })), "getConnection" in t && (r = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$dialect$2f$mysql$2f$mysql$2d$dialect$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MysqlDialect"](t)), "connect" in t && (r = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$dialect$2f$postgres$2f$postgres$2d$dialect$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PostgresDialect"]({
        pool: t
    })), {
        kysely: r ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$kysely$2f$dist$2f$esm$2f$kysely$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kysely"]({
            dialect: r
        }) : null,
        databaseType: n
    };
};
function Pe(e, t, r) {
    return r === "update" ? e : e == null && t.defaultValue ? typeof t.defaultValue == "function" ? t.defaultValue() : t.defaultValue : e;
}
var Wn = (e, t, r)=>{
    let n = Y(t);
    function o(a, c) {
        if (c === "id") return c;
        let p = n[a].fields[c];
        return p || console.log("Field not found", a, c), p.fieldName || c;
    }
    function i(a, c, p) {
        let { type: m = "sqlite" } = r || {}, u = n[c].fields[p];
        return u.type === "boolean" && m === "sqlite" && a !== null && a !== void 0 ? a ? 1 : 0 : u.type === "date" && a && a instanceof Date && m === "sqlite" ? a.toISOString() : a;
    }
    function d(a, c, p) {
        let { type: m = "sqlite" } = r || {}, u = n[c].fields[p];
        return u.type === "boolean" && m === "sqlite" && a !== null ? a === 1 : u.type === "date" && a ? new Date(a) : a;
    }
    function l(a) {
        return n[a].modelName;
    }
    let s = t?.advanced?.generateId === !1;
    return {
        transformInput (a, c, p) {
            let m = s || p === "update" ? {} : {
                id: t.advanced?.generateId ? t.advanced.generateId({
                    model: c
                }) : a.id || H()
            }, u = n[c].fields;
            for(let f in u){
                let g = a[f];
                m[u[f].fieldName || f] = Pe(i(g, c, f), u[f], p);
            }
            return m;
        },
        transformOutput (a, c, p = []) {
            if (!a) return null;
            let m = a.id ? p.length === 0 || p.includes("id") ? {
                id: a.id
            } : {} : {}, u = n[c].fields;
            for(let f in u){
                if (p.length && !p.includes(f)) continue;
                let g = u[f];
                g && (m[f] = d(a[g.fieldName || f], c, f));
            }
            return m;
        },
        convertWhereClause (a, c) {
            if (!c) return {
                and: null,
                or: null
            };
            let p = {
                and: [],
                or: []
            };
            return c.forEach((m)=>{
                let { field: u, value: f, operator: g = "=", connector: b = "AND" } = m, A = o(a, u), R = (h)=>g.toLowerCase() === "in" ? h(A, "in", Array.isArray(f) ? f : [
                        f
                    ]) : g === "contains" ? h(A, "like", `%${f}%`) : g === "starts_with" ? h(A, "like", `${f}%`) : g === "ends_with" ? h(A, "like", `%${f}`) : g === "eq" ? h(A, "=", f) : g === "ne" ? h(A, "<>", f) : g === "gt" ? h(A, ">", f) : g === "gte" ? h(A, ">=", f) : g === "lt" ? h(A, "<", f) : g === "lte" ? h(A, "<=", f) : h(A, g, f);
                b === "OR" ? p.or.push(R) : p.and.push(R);
            }), {
                and: p.and.length ? p.and : null,
                or: p.or.length ? p.or : null
            };
        },
        async withReturning (a, c, p, m) {
            let u;
            if (r?.type !== "mysql") u = await c.returningAll().executeTakeFirst();
            else {
                await c.execute();
                let f = a.id ? "id" : m[0].field ? m[0].field : "id", g = a[f] || m[0].value;
                u = await e.selectFrom(l(p)).selectAll().where(o(p, f), "=", g).executeTakeFirst();
            }
            return u;
        },
        getModelName: l,
        getField: o
    };
}, wr = (e, t)=>(r)=>{
        let { transformInput: n, withReturning: o, transformOutput: i, convertWhereClause: d, getModelName: l, getField: s } = Wn(e, r, t);
        return {
            id: "kysely",
            async create (a) {
                let { model: c, data: p, select: m } = a, u = n(p, c, "create"), f = e.insertInto(l(c)).values(u);
                return i(await o(u, f, c, []), c, m);
            },
            async findOne (a) {
                let { model: c, where: p, select: m } = a, { and: u, or: f } = d(c, p), g = e.selectFrom(l(c)).selectAll();
                u && (g = g.where((A)=>A.and(u.map((R)=>R(A))))), f && (g = g.where((A)=>A.or(f.map((R)=>R(A)))));
                let b = await g.executeTakeFirst();
                return b ? i(b, c, m) : null;
            },
            async findMany (a) {
                let { model: c, where: p, limit: m, offset: u, sortBy: f } = a, { and: g, or: b } = d(c, p), A = e.selectFrom(l(c));
                g && (A = A.where((h)=>h.and(g.map((y)=>y(h))))), b && (A = A.where((h)=>h.or(b.map((y)=>y(h))))), A = A.limit(m || 100), u && (A = A.offset(u)), f && (A = A.orderBy(s(c, f.field), f.direction));
                let R = await A.selectAll().execute();
                return R ? R.map((h)=>i(h, c)) : [];
            },
            async update (a) {
                let { model: c, where: p, update: m } = a, { and: u, or: f } = d(c, p), g = n(m, c, "update"), b = e.updateTable(l(c)).set(g);
                return u && (b = b.where((R)=>R.and(u.map((h)=>h(R))))), f && (b = b.where((R)=>R.or(f.map((h)=>h(R))))), await i(await o(g, b, c, p), c);
            },
            async updateMany (a) {
                let { model: c, where: p, update: m } = a, { and: u, or: f } = d(c, p), g = n(m, c, "update"), b = e.updateTable(l(c)).set(g);
                return u && (b = b.where((R)=>R.and(u.map((h)=>h(R))))), f && (b = b.where((R)=>R.or(f.map((h)=>h(R))))), (await b.execute()).length;
            },
            async delete (a) {
                let { model: c, where: p } = a, { and: m, or: u } = d(c, p), f = e.deleteFrom(l(c));
                m && (f = f.where((g)=>g.and(m.map((b)=>b(g))))), u && (f = f.where((g)=>g.or(u.map((b)=>b(g))))), await f.execute();
            },
            async deleteMany (a) {
                let { model: c, where: p } = a, { and: m, or: u } = d(c, p), f = e.deleteFrom(l(c));
                return m && (f = f.where((g)=>g.and(m.map((b)=>b(g))))), u && (f = f.where((g)=>g.or(u.map((b)=>b(g))))), (await f.execute()).length;
            },
            options: t
        };
    };
var Gn = (e)=>{
    let t = Y(e);
    function r(n, o) {
        return o === "id" ? o : t[n].fields[o].fieldName || o;
    }
    return {
        transformInput (n, o, i) {
            let d = i === "update" ? {} : {
                id: e.advanced?.generateId ? e.advanced.generateId({
                    model: o
                }) : n.id || H()
            }, l = t[o].fields;
            for(let s in l){
                let a = n[s];
                a === void 0 && !l[s].defaultValue || (d[l[s].fieldName || s] = Pe(a, l[s], i));
            }
            return d;
        },
        transformOutput (n, o, i = []) {
            if (!n) return null;
            let d = n.id || n._id ? i.length === 0 || i.includes("id") ? {
                id: n.id
            } : {} : {}, l = t[o].fields;
            for(let s in l){
                if (i.length && !i.includes(s)) continue;
                let a = l[s];
                a && (d[s] = n[a.fieldName || s]);
            }
            return d;
        },
        convertWhereClause (n, o, i) {
            return o.filter((d)=>n.every((l)=>{
                    let { field: s, value: a, operator: c } = l, p = r(i, s);
                    if (c === "in") {
                        if (!Array.isArray(a)) throw new Error("Value must be an array");
                        return a.includes(d[p]);
                    } else return c === "contains" ? d[p].includes(a) : c === "starts_with" ? d[p].startsWith(a) : c === "ends_with" ? d[p].endsWith(a) : d[p] === a;
                }));
        },
        getField: r
    };
}, br = (e)=>(t)=>{
        let { transformInput: r, transformOutput: n, convertWhereClause: o, getField: i } = Gn(t);
        return {
            id: "memory",
            create: async ({ model: d, data: l })=>{
                let s = r(l, d, "create");
                return e[d].push(s), n(s, d);
            },
            findOne: async ({ model: d, where: l, select: s })=>{
                let a = e[d], p = o(l, a, d)[0] || null;
                return n(p, d, s);
            },
            findMany: async ({ model: d, where: l, sortBy: s, limit: a, offset: c })=>{
                let p = e[d];
                return l && (p = o(l, p, d)), s && (p = p.sort((m, u)=>{
                    let f = i(d, s.field);
                    return s.direction === "asc" ? m[f] > u[f] ? 1 : -1 : m[f] < u[f] ? 1 : -1;
                })), c !== void 0 && (p = p.slice(c)), a !== void 0 && (p = p.slice(0, a)), p.map((m)=>n(m, d));
            },
            update: async ({ model: d, where: l, update: s })=>{
                let a = e[d], c = o(l, a, d);
                return c.forEach((p)=>{
                    Object.assign(p, r(s, d, "update"));
                }), n(c[0], d);
            },
            delete: async ({ model: d, where: l })=>{
                let s = e[d], a = o(l, s, d);
                e[d] = s.filter((c)=>!a.includes(c));
            },
            deleteMany: async ({ model: d, where: l })=>{
                let s = e[d], a = o(l, s, d), c = 0;
                return e[d] = s.filter((p)=>a.includes(p) ? (c++, !1) : !a.includes(p)), c;
            },
            updateMany (d) {
                let { model: l, where: s, update: a } = d, c = e[l], p = o(s, c, l);
                return p.forEach((m)=>{
                    Object.assign(m, a);
                }), p[0] || null;
            }
        };
    };
async function Ar(e) {
    if (!e.database) {
        let n = Y(e), o = Object.keys(n).reduce((i, d)=>(i[d] = [], i), {});
        return C.warn("No database configuration provided. Using memory adapter in development"), br(o)(e);
    }
    if (typeof e.database == "function") return e.database(e);
    let { kysely: t, databaseType: r } = await Ke(e);
    if (!t) throw new B("Failed to initialize database adapter");
    return wr(t, {
        type: r || "sqlite"
    })(e);
}
var Qe = "better-auth-secret-123456789";
;
async function kr(e, t) {
    let n = (await t.context.internalAdapter.findAccounts(e))?.find((d)=>d.providerId === "credential"), o = n?.password;
    if (!n || !o || !t.body.password) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "No password credential found"
    });
    if (!await t.context.password.verify({
        hash: o,
        password: t.body.password
    })) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIError"]("BAD_REQUEST", {
        message: "Invalid password"
    });
    return !0;
}
var Tr = async (e)=>{
    let t = await Ar(e), r = e.plugins || [], n = Jn(e), o = Ue(e.logger), i = pe(e.baseURL, e.basePath), d = e.secret || N.BETTER_AUTH_SECRET || N.AUTH_SECRET || Qe;
    d === Qe && ue && o.error("You are using the default secret. Please set `BETTER_AUTH_SECRET` in your environment variables or pass `secret` in your auth config."), e = {
        ...e,
        secret: d,
        baseURL: i ? new URL(i).origin : "",
        basePath: e.basePath || "/api/auth",
        plugins: r.concat(n),
        emailAndPassword: {
            ...e.emailAndPassword,
            enabled: e.emailAndPassword?.enabled ?? !1,
            autoSignIn: e.emailAndPassword?.autoSignIn ?? !0
        }
    };
    let l = it(e), s = Y(e), a = Object.keys(e.socialProviders || {}).map((u)=>{
        let f = e.socialProviders?.[u];
        return f.enabled === !1 ? null : (f.clientId || o.warn(`Social provider ${u} is missing clientId or clientSecret`), qe[u](f));
    }).filter((u)=>u !== null), c = ({ model: u, size: f })=>typeof e?.advanced?.generateId == "function" ? e.advanced.generateId({
            model: u,
            size: f
        }) : H(f), p = {
        appName: e.appName || "Better Auth",
        socialProviders: a,
        options: e,
        tables: s,
        trustedOrigins: Zn(e),
        baseURL: i || "",
        sessionConfig: {
            updateAge: e.session?.updateAge !== void 0 ? e.session.updateAge : 24 * 60 * 60,
            expiresIn: e.session?.expiresIn || 60 * 60 * 24 * 7,
            freshAge: e.session?.freshAge === void 0 ? 60 * 60 * 24 : e.session.freshAge
        },
        secret: d,
        rateLimit: {
            ...e.rateLimit,
            enabled: e.rateLimit?.enabled ?? ue,
            window: e.rateLimit?.window || 10,
            max: e.rateLimit?.max || 100,
            storage: e.rateLimit?.storage || (e.secondaryStorage ? "secondary-storage" : "memory")
        },
        authCookies: l,
        logger: o,
        generateId: c,
        session: null,
        secondaryStorage: e.secondaryStorage,
        password: {
            hash: e.emailAndPassword?.password?.hash || yt,
            verify: e.emailAndPassword?.password?.verify || wt,
            config: {
                minPasswordLength: e.emailAndPassword?.minPasswordLength || 8,
                maxPasswordLength: e.emailAndPassword?.maxPasswordLength || 128
            },
            checkPassword: kr
        },
        setNewSession (u) {
            this.newSession = u;
        },
        newSession: null,
        adapter: t,
        internalAdapter: Ge(t, {
            options: e,
            hooks: e.databaseHooks ? [
                e.databaseHooks
            ] : [],
            generateId: c
        }),
        createAuthCookie: Ne(e)
    }, { context: m } = Qn(p);
    return m;
};
function Qn(e) {
    let t = e.options, r = t.plugins || [], n = e, o = [];
    for (let i of r)if (i.init) {
        let d = i.init(e);
        typeof d == "object" && (d.options && (d.options.databaseHooks && o.push(d.options.databaseHooks), t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$defu$2f$dist$2f$defu$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["defu"])(t, d.options)), d.context && (n = {
            ...n,
            ...d.context
        }));
    }
    return o.push(t.databaseHooks), n.internalAdapter = Ge(e.adapter, {
        options: t,
        hooks: o.filter((i)=>i !== void 0),
        generateId: e.generateId
    }), n.options = t, {
        context: n
    };
}
function Jn(e) {
    let t = [];
    return e.advanced?.crossSubDomainCookies?.enabled, t;
}
function Zn(e) {
    let t = pe(e.baseURL, e.basePath);
    if (!t) return [];
    let r = [
        new URL(t).origin
    ];
    e.trustedOrigins && r.push(...e.trustedOrigins);
    let n = N.BETTER_AUTH_TRUSTED_ORIGINS;
    return n && r.push(...n.split(",")), r;
}
var au = (e)=>{
    let t = Tr(e), { api: r } = We(t, e), n = e.plugins?.reduce((o, i)=>i.$ERROR_CODES ? {
            ...o,
            ...i.$ERROR_CODES
        } : o, {});
    return {
        handler: async (o)=>{
            let i = await t, d = i.options.basePath || "/api/auth", l = new URL(o.url);
            if (!i.options.baseURL) {
                let a = pe(void 0, d) || `${l.origin}${d}`;
                i.options.baseURL = a, i.baseURL = a;
            }
            i.trustedOrigins = [
                ...e.trustedOrigins || [],
                i.baseURL,
                l.origin
            ];
            let { handler: s } = ur(i, e);
            return s(o);
        },
        api: r,
        options: e,
        $context: t,
        $Infer: {},
        $ERROR_CODES: {
            ...n,
            ...w
        }
    };
};
;
}}),
"[project]/node_modules/better-auth/dist/adapters/prisma.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "prismaAdapter": (()=>Ar)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/better-call/dist/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$random$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@better-auth/utils/dist/random.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hash$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@better-auth/utils/dist/hash.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hex$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@better-auth/utils/dist/hex.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/zod/lib/index.mjs [app-route] (ecmascript)");
;
;
var W = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    providerId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    accountId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    userId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    accessToken: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    refreshToken: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    idToken: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    accessTokenExpiresAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().nullish(),
    refreshTokenExpiresAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().nullish(),
    scope: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    password: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    createdAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date),
    updatedAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date)
}), J = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    email: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().transform((e)=>e.toLowerCase()),
    emailVerified: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].boolean().default(!1),
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    image: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    createdAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date),
    updatedAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date)
}), G = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    userId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    expiresAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date(),
    createdAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date),
    updatedAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date),
    token: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    ipAddress: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish(),
    userAgent: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().nullish()
}), z = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    createdAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date),
    updatedAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date().default(()=>new Date),
    expiresAt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].date(),
    identifier: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string()
});
var T = Object.create(null), b = (e)=>globalThis.process?.env || globalThis.Deno?.env.toObject() || globalThis.__env__ || (e ? T : globalThis), I = new Proxy(T, {
    get (e, i) {
        return b()[i] ?? T[i];
    },
    has (e, i) {
        let u = b();
        return i in u || i in T;
    },
    set (e, i, u) {
        let c = b(!0);
        return c[i] = u, !0;
    },
    deleteProperty (e, i) {
        if (!i) return !1;
        let u = b(!0);
        return delete u[i], !0;
    },
    ownKeys () {
        let e = b(!0);
        return Object.keys(e);
    }
});
function D(e) {
    return e ? e !== "false" : !1;
}
var N = typeof process < "u" && process.env && ("TURBOPACK compile-time value", "development") || "";
var q = N === "test" || D(I.TEST);
;
var v = (e)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$random$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createRandomStringGenerator"])("a-z", "A-Z", "0-9")(e || 32);
;
;
var A = class extends Error {
    constructor(i, u){
        super(i), this.name = "BetterAuthError", this.message = i, this.cause = u, this.stack = "";
    }
};
;
;
;
;
;
;
;
;
var B = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$random$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createRandomStringGenerator"])("a-z", "0-9", "A-Z", "-_");
var R = [
    "info",
    "success",
    "warn",
    "error",
    "debug"
];
function L(e, i) {
    return R.indexOf(i) <= R.indexOf(e);
}
var h = {
    reset: "\x1B[0m",
    bright: "\x1B[1m",
    dim: "\x1B[2m",
    underscore: "\x1B[4m",
    blink: "\x1B[5m",
    reverse: "\x1B[7m",
    hidden: "\x1B[8m",
    fg: {
        black: "\x1B[30m",
        red: "\x1B[31m",
        green: "\x1B[32m",
        yellow: "\x1B[33m",
        blue: "\x1B[34m",
        magenta: "\x1B[35m",
        cyan: "\x1B[36m",
        white: "\x1B[37m"
    },
    bg: {
        black: "\x1B[40m",
        red: "\x1B[41m",
        green: "\x1B[42m",
        yellow: "\x1B[43m",
        blue: "\x1B[44m",
        magenta: "\x1B[45m",
        cyan: "\x1B[46m",
        white: "\x1B[47m"
    }
}, P = {
    info: h.fg.blue,
    success: h.fg.green,
    warn: h.fg.yellow,
    error: h.fg.red,
    debug: h.fg.magenta
}, E = (e, i)=>{
    let u = new Date().toISOString();
    return `${h.dim}${u}${h.reset} ${P[e]}${e.toUpperCase()}${h.reset} ${h.bright}[Better Auth]:${h.reset} ${i}`;
}, O = (e)=>{
    let i = e?.disabled !== !0, u = e?.level ?? "error", c = (l, y, f = [])=>{
        if (!i || !L(u, l)) return;
        let a = E(l, y);
        if (!e || typeof e.log != "function") {
            l === "error" ? console.error(a, ...f) : l === "warn" ? console.warn(a, ...f) : console.log(a, ...f);
            return;
        }
        e.log(l === "success" ? "info" : l, a, ...f);
    };
    return Object.fromEntries(R.map((l)=>[
            l,
            (...[y, ...f])=>c(l, y, f)
        ]));
}, M = O();
var w = (e)=>{
    let i = e.plugins?.reduce((s, p)=>{
        let d = p.schema;
        if (!d) return s;
        for (let [t, o] of Object.entries(d))s[t] = {
            fields: {
                ...s[t]?.fields,
                ...o.fields
            },
            modelName: o.modelName || t
        };
        return s;
    }, {}), u = e.rateLimit?.storage === "database", c = {
        rateLimit: {
            modelName: e.rateLimit?.modelName || "rateLimit",
            fields: {
                key: {
                    type: "string",
                    fieldName: e.rateLimit?.fields?.key || "key"
                },
                count: {
                    type: "number",
                    fieldName: e.rateLimit?.fields?.count || "count"
                },
                lastRequest: {
                    type: "number",
                    fieldName: e.rateLimit?.fields?.lastRequest || "lastRequest"
                }
            }
        }
    }, { user: l, session: y, account: f, ...a } = i || {};
    return {
        user: {
            modelName: e.user?.modelName || "user",
            fields: {
                name: {
                    type: "string",
                    required: !0,
                    fieldName: e.user?.fields?.name || "name"
                },
                email: {
                    type: "string",
                    unique: !0,
                    required: !0,
                    fieldName: e.user?.fields?.email || "email"
                },
                emailVerified: {
                    type: "boolean",
                    defaultValue: ()=>!1,
                    required: !0,
                    fieldName: e.user?.fields?.emailVerified || "emailVerified"
                },
                image: {
                    type: "string",
                    required: !1,
                    fieldName: e.user?.fields?.image || "image"
                },
                createdAt: {
                    type: "date",
                    defaultValue: ()=>new Date,
                    required: !0,
                    fieldName: e.user?.fields?.createdAt || "createdAt"
                },
                updatedAt: {
                    type: "date",
                    defaultValue: ()=>new Date,
                    required: !0,
                    fieldName: e.user?.fields?.updatedAt || "updatedAt"
                },
                ...l?.fields,
                ...e.user?.additionalFields
            },
            order: 1
        },
        session: {
            modelName: e.session?.modelName || "session",
            fields: {
                expiresAt: {
                    type: "date",
                    required: !0,
                    fieldName: e.session?.fields?.expiresAt || "expiresAt"
                },
                token: {
                    type: "string",
                    required: !0,
                    fieldName: e.session?.fields?.token || "token",
                    unique: !0
                },
                createdAt: {
                    type: "date",
                    required: !0,
                    fieldName: e.session?.fields?.createdAt || "createdAt"
                },
                updatedAt: {
                    type: "date",
                    required: !0,
                    fieldName: e.session?.fields?.updatedAt || "updatedAt"
                },
                ipAddress: {
                    type: "string",
                    required: !1,
                    fieldName: e.session?.fields?.ipAddress || "ipAddress"
                },
                userAgent: {
                    type: "string",
                    required: !1,
                    fieldName: e.session?.fields?.userAgent || "userAgent"
                },
                userId: {
                    type: "string",
                    fieldName: e.session?.fields?.userId || "userId",
                    references: {
                        model: e.user?.modelName || "user",
                        field: "id",
                        onDelete: "cascade"
                    },
                    required: !0
                },
                ...y?.fields,
                ...e.session?.additionalFields
            },
            order: 2
        },
        account: {
            modelName: e.account?.modelName || "account",
            fields: {
                accountId: {
                    type: "string",
                    required: !0,
                    fieldName: e.account?.fields?.accountId || "accountId"
                },
                providerId: {
                    type: "string",
                    required: !0,
                    fieldName: e.account?.fields?.providerId || "providerId"
                },
                userId: {
                    type: "string",
                    references: {
                        model: e.user?.modelName || "user",
                        field: "id",
                        onDelete: "cascade"
                    },
                    required: !0,
                    fieldName: e.account?.fields?.userId || "userId"
                },
                accessToken: {
                    type: "string",
                    required: !1,
                    fieldName: e.account?.fields?.accessToken || "accessToken"
                },
                refreshToken: {
                    type: "string",
                    required: !1,
                    fieldName: e.account?.fields?.refreshToken || "refreshToken"
                },
                idToken: {
                    type: "string",
                    required: !1,
                    fieldName: e.account?.fields?.idToken || "idToken"
                },
                accessTokenExpiresAt: {
                    type: "date",
                    required: !1,
                    fieldName: e.account?.fields?.accessTokenExpiresAt || "accessTokenExpiresAt"
                },
                refreshTokenExpiresAt: {
                    type: "date",
                    required: !1,
                    fieldName: e.account?.fields?.accessTokenExpiresAt || "refreshTokenExpiresAt"
                },
                scope: {
                    type: "string",
                    required: !1,
                    fieldName: e.account?.fields?.scope || "scope"
                },
                password: {
                    type: "string",
                    required: !1,
                    fieldName: e.account?.fields?.password || "password"
                },
                createdAt: {
                    type: "date",
                    required: !0,
                    fieldName: e.account?.fields?.createdAt || "createdAt"
                },
                updatedAt: {
                    type: "date",
                    required: !0,
                    fieldName: e.account?.fields?.updatedAt || "updatedAt"
                },
                ...f?.fields
            },
            order: 3
        },
        verification: {
            modelName: e.verification?.modelName || "verification",
            fields: {
                identifier: {
                    type: "string",
                    required: !0,
                    fieldName: e.verification?.fields?.identifier || "identifier"
                },
                value: {
                    type: "string",
                    required: !0,
                    fieldName: e.verification?.fields?.value || "value"
                },
                expiresAt: {
                    type: "date",
                    required: !0,
                    fieldName: e.verification?.fields?.expiresAt || "expiresAt"
                },
                createdAt: {
                    type: "date",
                    required: !1,
                    defaultValue: ()=>new Date,
                    fieldName: e.verification?.fields?.createdAt || "createdAt"
                },
                updatedAt: {
                    type: "date",
                    required: !1,
                    defaultValue: ()=>new Date,
                    fieldName: e.verification?.fields?.updatedAt || "updatedAt"
                }
            },
            order: 4
        },
        ...a,
        ...u ? c : {}
    };
};
;
;
;
function k(e, i, u) {
    return u === "update" ? e : e == null && i.defaultValue ? typeof i.defaultValue == "function" ? i.defaultValue() : i.defaultValue : e;
}
var C = (e, i)=>{
    let u = w(i);
    function c(a, s) {
        return s === "id" ? s : u[a].fields[s].fieldName || s;
    }
    function l(a) {
        switch(a){
            case "starts_with":
                return "startsWith";
            case "ends_with":
                return "endsWith";
            default:
                return a;
        }
    }
    function y(a) {
        return u[a].modelName;
    }
    let f = i?.advanced?.generateId === !1;
    return {
        transformInput (a, s, p) {
            let d = f || p === "update" ? {} : {
                id: i.advanced?.generateId ? i.advanced.generateId({
                    model: s
                }) : a.id || v()
            }, t = u[s].fields;
            for(let o in t){
                let r = a[o];
                r === void 0 && (!t[o].defaultValue || p === "update") || (d[t[o].fieldName || o] = k(r, t[o], p));
            }
            return d;
        },
        transformOutput (a, s, p = []) {
            if (!a) return null;
            let d = a.id || a._id ? p.length === 0 || p.includes("id") ? {
                id: a.id
            } : {} : {}, t = u[s].fields;
            for(let o in t){
                if (p.length && !p.includes(o)) continue;
                let r = t[o];
                r && (d[o] = a[r.fieldName || o]);
            }
            return d;
        },
        convertWhereClause (a, s) {
            if (!s) return {};
            if (s.length === 1) {
                let r = s[0];
                return r ? {
                    [c(a, r.field)]: r.operator === "eq" || !r.operator ? r.value : {
                        [l(r.operator)]: r.value
                    }
                } : void 0;
            }
            let p = s.filter((r)=>r.connector === "AND" || !r.connector), d = s.filter((r)=>r.connector === "OR"), t = p.map((r)=>({
                    [c(a, r.field)]: r.operator === "eq" || !r.operator ? r.value : {
                        [l(r.operator)]: r.value
                    }
                })), o = d.map((r)=>({
                    [c(a, r.field)]: {
                        [r.operator || "eq"]: r.value
                    }
                }));
            return {
                ...t.length ? {
                    AND: t
                } : {},
                ...o.length ? {
                    OR: o
                } : {}
            };
        },
        convertSelect: (a, s)=>{
            if (!(!a || !s)) return a.reduce((p, d)=>({
                    ...p,
                    [c(s, d)]: !0
                }), {});
        },
        getModelName: y,
        getField: c
    };
}, Ar = (e, i)=>(u)=>{
        let c = e, { transformInput: l, transformOutput: y, convertWhereClause: f, convertSelect: a, getModelName: s, getField: p } = C(i, u);
        return {
            id: "prisma",
            async create (d) {
                let { model: t, data: o, select: r } = d, m = l(o, t, "create");
                if (!c[s(t)]) throw new A(`Model ${t} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`);
                let g = await c[s(t)].create({
                    data: m,
                    select: a(r, t)
                });
                return y(g, t, r);
            },
            async findOne (d) {
                let { model: t, where: o, select: r } = d, m = f(t, o);
                if (!c[s(t)]) throw new A(`Model ${t} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`);
                let g = await c[s(t)].findFirst({
                    where: m,
                    select: a(r, t)
                });
                return y(g, t, r);
            },
            async findMany (d) {
                let { model: t, where: o, limit: r, offset: m, sortBy: g } = d, x = f(t, o);
                if (!c[s(t)]) throw new A(`Model ${t} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`);
                return (await c[s(t)].findMany({
                    where: x,
                    take: r || 100,
                    skip: m || 0,
                    ...g?.field ? {
                        orderBy: {
                            [p(t, g.field)]: g.direction === "desc" ? "desc" : "asc"
                        }
                    } : {}
                })).map((F)=>y(F, t));
            },
            async update (d) {
                let { model: t, where: o, update: r } = d;
                if (!c[s(t)]) throw new A(`Model ${t} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`);
                let m = f(t, o), g = l(r, t, "update"), x = await c[s(t)].update({
                    where: m,
                    data: g
                });
                return y(x, t);
            },
            async updateMany (d) {
                let { model: t, where: o, update: r } = d, m = f(t, o), g = l(r, t, "update"), x = await c[s(t)].updateMany({
                    where: m,
                    data: g
                });
                return x ? x.count : 0;
            },
            async delete (d) {
                let { model: t, where: o } = d, r = f(t, o);
                try {
                    await c[s(t)].delete({
                        where: r
                    });
                } catch  {}
            },
            async deleteMany (d) {
                let { model: t, where: o } = d, r = f(t, o), m = await c[s(t)].deleteMany({
                    where: r
                });
                return m ? m.count : 0;
            },
            options: i
        };
    };
;
}}),
"[project]/node_modules/better-auth/dist/next-js.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "nextCookies": (()=>J),
    "toNextJsHandler": (()=>V)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/headers.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$base64$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@better-auth/utils/dist/base64.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hmac$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@better-auth/utils/dist/hmac.mjs [app-route] (ecmascript)");
;
var m = Object.create(null), a = (e)=>globalThis.process?.env || globalThis.Deno?.env.toObject() || globalThis.__env__ || (e ? m : globalThis), T = new Proxy(m, {
    get (e, t) {
        return a()[t] ?? m[t];
    },
    has (e, t) {
        let o = a();
        return t in o || t in m;
    },
    set (e, t, o) {
        let i = a(!0);
        return i[t] = o, !0;
    },
    deleteProperty (e, t) {
        if (!t) return !1;
        let o = a(!0);
        return delete o[t], !0;
    },
    ownKeys () {
        let e = a(!0);
        return Object.keys(e);
    }
});
function C(e) {
    return e ? e !== "false" : !1;
}
var y = typeof process < "u" && process.env && ("TURBOPACK compile-time value", "development") || "";
var w = y === "test" || C(T.TEST);
;
;
function h(e) {
    let t = new Map;
    return e.split(", ").forEach((i)=>{
        let d = i.split(";").map((l)=>l.trim()), [n, ...c] = d, [u, ...p] = n.split("="), f = p.join("=");
        if (!u || f === void 0) return;
        let r = {
            value: f
        };
        c.forEach((l)=>{
            let [b, ...k] = l.split("="), s = k.join("="), g = b.trim().toLowerCase();
            switch(g){
                case "max-age":
                    r["max-age"] = s ? parseInt(s.trim(), 10) : void 0;
                    break;
                case "expires":
                    r.expires = s ? new Date(s.trim()) : void 0;
                    break;
                case "domain":
                    r.domain = s ? s.trim() : void 0;
                    break;
                case "path":
                    r.path = s ? s.trim() : void 0;
                    break;
                case "secure":
                    r.secure = !0;
                    break;
                case "httponly":
                    r.httponly = !0;
                    break;
                case "samesite":
                    r.samesite = s ? s.trim().toLowerCase() : void 0;
                    break;
                default:
                    r[g] = s ? s.trim() : !0;
                    break;
            }
        }), t.set(u, r);
    }), t;
}
function V(e) {
    let t = async (o)=>"handler" in e ? e.handler(o) : e(o);
    return {
        GET: t,
        POST: t
    };
}
var J = ()=>({
        id: "next-cookies",
        hooks: {
            after: [
                {
                    matcher (e) {
                        return !0;
                    },
                    handler: async (e)=>{
                        let t = e.responseHeader;
                        if (!("_flag" in e && e._flag === "router") && t instanceof Headers) {
                            let o = t?.get("set-cookie");
                            if (!o) return;
                            let i = h(o), d = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
                            i.forEach((n, c)=>{
                                if (!c) return;
                                let u = {
                                    sameSite: n.samesite,
                                    secure: n.secure,
                                    maxAge: n["max-age"],
                                    httpOnly: n.httponly,
                                    domain: n.domain,
                                    path: n.path
                                };
                                try {
                                    d.set(c, decodeURIComponent(n.value), u);
                                } catch  {}
                            });
                            return;
                        }
                    }
                }
            ]
        }
    });
;
}}),

};

//# sourceMappingURL=node_modules_better-auth_dist_003810._.js.map